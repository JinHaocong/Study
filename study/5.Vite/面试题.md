# 什么是vite？他与webpack有什么区别？

Vite（发音为“veet”）是一种现代化的前端构建工具，专为Vue.js 框架优化。它的目标是提供快速的开发体验，尤其是在大型单页面应用程序（SPA）中。以下是一些 Vite 与 Webpack 之间的主要区别：

1. **开发服务器速度：**
   - **Vite：** 使用了基于 ES Module 的开发服务器，它只会为每个模块提供必要的代码，实现了按需编译，因此启动速度更快。
   - **Webpack：** 通常需要在启动时编译整个项目，因此启动速度可能较慢。
2. **热模块替换（HMR）：**
   - **Vite：** 利用 ES Module 的优势，实现了更快的热模块替换，使开发过程更加流畅。
   - **Webpack：** 也支持 HMR，但在某些情况下可能不如 Vite 快速。
3. **构建速度：**
   - **Vite：** 由于采用了基于浏览器原生支持的 ES Module 的开发服务器，构建速度较快。
   - **Webpack：** 需要在构建时进行更多的处理，可能相对较慢。
4. **配置：**
   - **Vite：** 提供了一种零配置的选项，使得配置变得更加简单。
   - **Webpack：** 通常需要手动配置，尽管有一些预设配置和插件可用。
5. **生态系统：**
   - **Vite：** 主要面向 Vue.js 生态系统，但也可以用于其他框架。
   - **Webpack：** 更通用，支持各种前端框架和库。

总体而言，Vite 的设计目标是提供更快的开发体验，而Webpack 则更加通用且适用于更广泛的场景。选择使用哪个工具取决于项目的需求以及开发者的偏好。

# vite相较于webpack的优势在哪？

Vite 相较于 Webpack 具有一些优势，特别是在开发体验和性能方面。以下是一些 Vite 相对于 Webpack 的优势：

1. **更快的启动速度：**
   - Vite 利用 ES Module 的按需加载，通过仅编译需要的模块，大大加快了开发服务器的启动速度。这对于快速的开发迭代非常有利。
2. **更快的热模块替换（HMR）：**
   - Vite 利用 ES Module 的优势，实现了更快的热模块替换，使得在开发过程中的修改能够更迅速地反映在浏览器中，提高了开发效率。
3. **基于原生 ES Module：**
   - Vite 利用浏览器原生支持的 ES Module，避免了传统打包工具中的模块化翻译和打包过程，减少了不必要的处理，提高了性能。
4. **零配置开发：**
   - Vite 提供了一种零配置的选项，使得开发者无需复杂的配置即可开始项目。这简化了项目配置的过程，降低了学习曲线。
5. **更适合单页面应用（SPA）：**
   - Vite 的设计目标之一是为 Vue.js 提供更好的开发体验，因此在处理单页面应用时表现得更为出色。它的架构使得按需加载和构建速度更加优越。
6. **现代化的构建工具：**
   - Vite 是一个较为新的构建工具，借鉴了现代前端开发的最佳实践。它的设计目标是针对当今前端项目的需求提供更优秀的开发体验。

需要注意的是，选择使用 Vite 还是 Webpack 取决于项目的具体需求和开发者的偏好。一些项目可能更适合使用 Vite，而另一些可能更适合使用 Webpack。

# vite脚手架和vite有什么区别？

"Vite" 通常指的是一个前端构建工具，而 "Vite 脚手架" 可能指的是使用 Vite 构建的项目的初始化模板或脚手架工具。让我们更详细地了解它们的区别：

1. **Vite（前端构建工具）：**
   - Vite 是一个由尤雨溪（Vue.js 的创始人）开发的现代化前端构建工具，主要面向 Vue.js 项目。它的目标是提供快速的开发体验，通过利用浏览器原生支持的 ES Module，实现了按需加载和更快的构建速度。Vite支持多种前端框架，并且可以作为一个通用的构建工具使用。
2. **Vite 脚手架：**
   - Vite 脚手架通常是指一些用于初始化 Vite 项目的模板或工具。这些脚手架可以提供一个项目的基础结构、配置和一些常用的功能。通过使用 Vite 脚手架，开发者可以更快速地启动新项目，而无需从头开始配置。这些脚手架可能是官方提供的，也可能是由社区或个人创建的。

总体而言，Vite 是一个前端构建工具，而 Vite 脚手架是一种方便的工具或模板，用于加速使用 Vite 构建的项目的起步过程。在学习或使用 Vite 时，你可能会听到这两个术语，它们指的是构建工具和构建工具的初始化工具之间的关系。

- create-vite 内置 vite
- vue-cli 内置 webpack

# vite 是如何让浏览器识别.vue文件的？

Vite 使用了一种基于浏览器原生模块系统的开发服务器，它使用了浏览器的 ESM（ECMAScript 模块）加载能力。在 Vite 中，`.vue` 文件的处理是通过 Vite 插件和浏览器的原生 ESM 功能实现的。

下面是 Vite 是如何让浏览器识别 `.vue` 文件的基本原理：

1. **Vite 插件：** Vite 使用了一个名为 `vite-plugin-vue` 的插件，该插件负责处理 `.vue` 文件。该插件会拦截 `.vue` 文件的导入，然后对其进行解析和转换。
2. **Vue 单文件组件（SFC）解析：** `.vue` 文件是 Vue 单文件组件，包含了模板、脚本和样式等部分。Vite 插件会解析 `.vue` 文件，提取出其中的模板、脚本和样式，并将它们分别作为独立的模块。
3. **动态导入：** Vite 利用浏览器原生的动态导入（Dynamic Import）功能。每当一个 `.vue` 文件被导入时，Vite 会将该文件拆分成单独的模块，并使用动态导入将这些模块引入到浏览器中。
4. **浏览器原生模块系统：** 现代浏览器支持原生的 ESM（ECMAScript 模块）加载，这使得浏览器可以以非常高效的方式加载模块。Vite 利用了这一特性，将拆分后的模块通过原生 ESM 在浏览器中加载和执行。

总体来说，Vite通过将Vue单文件组件拆分成原生的模块，并利用浏览器的原生模块系统加载这些模块，实现了对`.vue`文件的高效处理和加载。这种方式相较于传统的打包工具，可以更加快速地实现模块的按需加载。

# vite的依赖预构建是什么？有什么作用？

Vite 的依赖预构建（Dependency Pre-bundling）是 Vite 构建过程中的一个优化特性，旨在提高应用程序的启动性能。它的主要作用是将应用程序的依赖项提前构建成预构建（pre-bundled）的形式，以减少在浏览器中实际加载和执行这些依赖项的时间。

具体来说，依赖预构建有以下作用：

1. **减少加载时间：** 将应用程序的依赖项提前构建成预构建包可以减少浏览器在加载应用程序时需要下载和解析的文件数量。这可以显著减少初始加载时间，因为预构建的包通常是经过优化和压缩的。
2. **提高启动性能：** 减少加载时间意味着应用程序可以更快地启动。用户能够更迅速地看到应用程序的首屏内容，提升了用户体验。
3. **更小的网络负载：** 预构建的依赖包往往比未优化的原始依赖文件更小。这意味着应用程序在首次加载时需要传输的数据量更少，降低了网络负载。
4. **更好的缓存利用：** 预构建的包通常会带有稳定的哈希值，这有助于更好地利用浏览器缓存。当应用程序的代码发生变化时，哈希值会发生变化，浏览器会重新下载最新的预构建包，确保用户始终获取到最新的代码。

在 Vite 中，依赖预构建是默认启用的。Vite 会根据你的项目配置和依赖关系，生成优化的预构建包。这个特性是 Vite 实现快速启动性能的一个关键因素之一，使得开发者可以更好地享受现代前端开发的高效性。

# 什么是postcss？有什么作用？

PostCSS 是一个用于处理样式的工具，它通过使用 JavaScript 插件对 CSS 进行转换。与传统的预处理器（如 Sass 或 Less）不同，PostCSS 不引入新的样式语言，而是通过插件系统来处理原生的 CSS 代码。

PostCSS 的主要作用包括：

1. **自动添加浏览器前缀：** 使用插件如 autoprefixer，自动为 CSS 属性添加适当的浏览器前缀，以确保在不同浏览器中获得一致的表现。
2. **CSS 压缩：** 通过插件如 cssnano，可以压缩 CSS 代码，减小文件大小，提高页面加载性能。
3. **变量和混合处理：** PostCSS 可以处理类似于 Sass 或 Less 中的变量和混合，使得开发者可以更方便地组织和维护样式。
4. **未来 CSS 特性支持：** 使用 PostCSS 插件，可以提前使用一些浏览器尚未原生支持的 CSS 特性，使开发者能够更早地体验和使用新功能。
5. **代码 linting：** 通过插件进行代码 linting，帮助发现和修复潜在的代码问题，提高代码质量。
6. **模块化 CSS：** PostCSS 支持模块化的 CSS，使得样式能够更好地组织为模块，提高可维护性。
7. **支持 CSS-in-JS：** PostCSS 可以与一些 CSS-in-JS 解决方案集成，使开发者能够在 JavaScript 中更灵活地处理样式。

总体而言，PostCSS 提供了一种灵活、可扩展的方式来处理和优化样式代码，使得前端开发者能够更高效地管理和改进他们的样式表。

# vite独有的钩子有哪些？

### `config`

- **类型：** `(config: UserConfig, env: { mode: string, command: string }) => UserConfig | null | void`

- **种类：** `async`, `sequential`

  **在解析 Vite 配置前调用。**钩子接收原始用户配置（命令行选项指定的会与配置文件合并）和一个描述配置环境的变量，包含正在使用的 `mode` 和 `command`。它可以返回一个将被深度合并到现有配置中的部分配置对象，或者直接改变配置（如果默认的合并不能达到预期的结果）。

  **示例：**

  ```js
  // 返回部分配置（推荐）
  const partialConfigPlugin = () => ({
    name: 'return-partial',
    config: () => ({
      resolve: {
        alias: {
          foo: 'bar',
        },
      },
    }),
  })
  
  // 直接改变配置（应仅在合并不起作用时使用）
  const mutateConfigPlugin = () => ({
    name: 'mutate-config',
    config(config, { command }) {
      if (command === 'build') {
        config.root = 'foo'
      }
    },
  })
  ```

  注意

  用户插件在运行这个钩子之前会被解析，因此在 `config` 钩子中注入其他插件不会有任何效果。

### `configResolved`

- **类型：** `(config: ResolvedConfig) => void | Promise<void>`

- **种类：** `async`, `parallel`

  **在解析 Vite 配置后调用。**使用这个钩子读取和存储最终解析的配置。当插件需要根据运行的命令做一些不同的事情时，它也很有用。

  **示例：**

  ```js
  const examplePlugin = () => {
    let config
  
    return {
      name: 'read-config',
  
      configResolved(resolvedConfig) {
        // 存储最终解析的配置
        config = resolvedConfig
      },
  
      // 在其他钩子中使用存储的配置
      transform(code, id) {
        if (config.command === 'serve') {
          // dev: 由开发服务器调用的插件
        } else {
          // build: 由 Rollup 调用的插件
        }
      },
    }
  }
  ```

  注意，在开发环境下，`command` 的值为 `serve`（在 CLI 中，`vite` 和 `vite dev` 是 `vite serve` 的别名）。

### `configureServer`

- **类型：** `(server: ViteDevServer) => (() => void) | void | Promise<(() => void) | void>`

- **种类：** `async`, `sequential`

- **此外请看** [ViteDevServer](https://cn.vitejs.dev/guide/api-javascript.html#vitedevserver)

  **是用于配置开发服务器的钩子。**最常见的用例是在内部 [connect](https://github.com/senchalabs/connect) 应用程序中添加自定义中间件:

  ```js
  const myPlugin = () => ({
    name: 'configure-server',
    configureServer(server) {
      server.middlewares.use((req, res, next) => {
        // 自定义请求处理...
      })
    },
  })
  ```

  **注入后置中间件**

  `configureServer` 钩子将在内部中间件被安装前调用，所以自定义的中间件将会默认会比内部中间件早运行。如果你想注入一个在内部中间件 **之后** 运行的中间件，你可以从 `configureServer` 返回一个函数，将会在内部中间件安装后被调用：

  ```js
  const myPlugin = () => ({
    name: 'configure-server',
    configureServer(server) {
      // 返回一个在内部中间件安装后
      // 被调用的后置钩子
      return () => {
        server.middlewares.use((req, res, next) => {
          // 自定义请求处理...
        })
      }
    },
  })
  ```

  **存储服务器访问**

  在某些情况下，其他插件钩子可能需要访问开发服务器实例（例如访问 websocket 服务器、文件系统监视程序或模块图）。这个钩子也可以用来存储服务器实例以供其他钩子访问:

  ```js
  const myPlugin = () => {
    let server
    return {
      name: 'configure-server',
      configureServer(_server) {
        server = _server
      },
      transform(code, id) {
        if (server) {
          // 使用 server...
        }
      },
    }
  }
  ```

  注意 `configureServer` 在运行生产版本时不会被调用，所以其他钩子需要防范它缺失。

### `configurePreviewServer`

- **类型：** `(server: PreviewServer) => (() => void) | void | Promise<(() => void) | void>`

- **种类：** `async`, `sequential`

- **参见：** [PreviewServerForHook](https://cn.vitejs.dev/guide/api-javascript.html#previewserverforhook)

  与 [`configureServer`](https://cn.vitejs.dev/guide/api-plugin.html#configureserver) 相同，但用于预览服务器。`configurePreviewServer` 这个钩子与 `configureServer` 类似，也是在其他中间件安装前被调用。如果你想要在其他中间件 **之后** 安装一个插件，你可以从 `configurePreviewServer` 返回一个函数，它将会在内部中间件被安装之后再调用：

  ```js
  const myPlugin = () => ({
    name: 'configure-preview-server',
    configurePreviewServer(server) {
      // 返回一个钩子，会在其他中间件安装完成后调用
      return () => {
        server.middlewares.use((req, res, next) => {
          // 自定义处理请求 ...
        })
      }
    },
  })
  ```

### `transformIndexHtml`

- **类型：** `IndexHtmlTransformHook | { order?: 'pre' | 'post', handler: IndexHtmlTransformHook }`

- **种类：** `async`, `sequential`

  转换 `index.html` 的专用钩子。钩子接收当前的 HTML 字符串和转换上下文。上下文在开发期间暴露[`ViteDevServer`](https://cn.vitejs.dev/guide/api-javascript.html#vitedevserver)实例，在构建期间暴露 Rollup 输出的包。

  这个钩子可以是异步的，并且可以返回以下其中之一:

  - 经过转换的 HTML 字符串
  - 注入到现有 HTML 中的标签描述符对象数组（`{ tag, attrs, children }`）。每个标签也可以指定它应该被注入到哪里（默认是在 `<head>` 之前）
  - 一个包含 `{ html, tags }` 的对象

  默认情况下 `order` 是 `undefined`，这个钩子会在 HTML 被转换后应用。为了注入一个应该通过 Vite 插件管道的脚本， `order: 'pre'` 指将在处理 HTML 之前应用。 `order: 'post'` 是在所有未定义的 `order` 的钩子函数被应用后才应用。

  **基础示例：**

  ```js
  const htmlPlugin = () => {
    return {
      name: 'html-transform',
      transformIndexHtml(html) {
        return html.replace(
          /<title>(.*?)<\/title>/,
          `<title>Title replaced!</title>`,
        )
      },
    }
  }
  ```

  **完整钩子签名：**

  ```ts
  type IndexHtmlTransformHook = (
    html: string,
    ctx: {
      path: string
      filename: string
      server?: ViteDevServer
      bundle?: import('rollup').OutputBundle
      chunk?: import('rollup').OutputChunk
    },
  ) =>
    | IndexHtmlTransformResult
    | void
    | Promise<IndexHtmlTransformResult | void>
  
  type IndexHtmlTransformResult =
    | string
    | HtmlTagDescriptor[]
    | {
        html: string
        tags: HtmlTagDescriptor[]
      }
  
  interface HtmlTagDescriptor {
    tag: string
    attrs?: Record<string, string>
    children?: string | HtmlTagDescriptor[]
    /**
     * 默认： 'head-prepend'
     */
    injectTo?: 'head' | 'body' | 'head-prepend' | 'body-prepend'
  }
  ```

### `handleHotUpdate`

- **类型：** `(ctx: HmrContext) => Array<ModuleNode> | void | Promise<Array<ModuleNode> | void>`

  执行自定义 HMR 更新处理。钩子接收一个带有以下签名的上下文对象：

  ```ts
  interface HmrContext {
    file: string
    timestamp: number
    modules: Array<ModuleNode>
    read: () => string | Promise<string>
    server: ViteDevServer
  }
  ```

  - `modules` 是受更改文件影响的模块数组。它是一个数组，因为单个文件可能映射到多个服务模块（例如 Vue 单文件组件）。
  - `read` 这是一个异步读函数，它返回文件的内容。之所以这样做，是因为在某些系统上，文件更改的回调函数可能会在编辑器完成文件更新之前过快地触发，并 `fs.readFile` 直接会返回空内容。传入的 `read` 函数规范了这种行为。

  钩子可以选择:

  - 过滤和缩小受影响的模块列表，使 HMR 更准确。

  - 返回一个空数组，并通过向客户端发送自定义事件来执行完整的自定义 HMR 处理:

    ```js
    handleHotUpdate({ server }) {
      server.ws.send({
        type: 'custom',
        event: 'special-update',
        data: {}
      })
      return []
    }
    ```

    客户端代码应该使用 [HMR API](https://cn.vitejs.dev/guide/api-hmr.html) 注册相应的处理器（这应该被相同插件的 `transform` 钩子注入）：

    ```js
    if (import.meta.hot) {
      import.meta.hot.on('special-update', (data) => {
        // 执行自定义更新
      })
    }
    ```

# 插件执行顺序

一个 Vite 插件可以额外指定一个 `enforce` 属性（类似于 webpack 加载器）来调整它的应用顺序。`enforce` 的值可以是`pre` 或 `post`。解析后的插件将按照以下顺序排列：

- Alias
- 带有 `enforce: 'pre'` 的用户插件
- Vite 核心插件
- 没有 enforce 值的用户插件
- Vite 构建用的插件
- 带有 `enforce: 'post'` 的用户插件
- Vite 后置构建插件（最小化，manifest，报告）

# 手写vite-aliases

config生命周期

1. 需要在读取配置前重新覆盖user的配置
2. 读取src目录下的文件
3. 过滤掉文件，只保留目录
4. 创建别名映射对象
5. 返回对象即可

```js
// vite的插件必须返回给vite一个配置对象

import path from "path";
import fs from "fs";


// 过滤掉文件 只保留目录
// 过滤掉文件，只保留目录
function filterDirectories(files, basePath) {
    return files.filter((fileName) => {
        // fs.statSync 方法用于获取文件的状态信息，包括文件类型、大小、创建时间等。
        const fileStat = fs.statSync(path.join(basePath, fileName));
        // 只返回目录
        return fileStat.isDirectory();
    });
}


// 获取别名配置对象
function getAliasOptions(prefix, basePath) {
    const result = filterDirectories(fs.readdirSync(basePath), basePath);

    const aliasObj = {
        [prefix]: basePath,
    };

    result.forEach((dir) => {
        aliasObj[`${prefix}${dir}`] = path.join(basePath, dir);
    });

    return aliasObj;
}


export default ({prefix}) => {
    return {
        // config 返回的配置对象会覆盖掉原有的配置
        config(config, env) {
            // config: UserConfig
            // env: { mode: string, command: string })
            // mode: development production
            // command: build dev
            const srcPath = path.join(__dirname, '../src');
            const aliasOptions = getAliasOptions(prefix, srcPath);

            return {
                resolve: {
                    alias: aliasOptions,
                },
            }
        }
    }
}

```

# 手写vite-plugin-html的inject data功能

transformIndexHtml生命周期

就是字符串替换

```js
function transformHtmlHandler(html, options) {
    const dataMap = (options.inject && options.inject.data) || {};
    let newHtml = html;

    for (const key in dataMap) {
        newHtml = newHtml.replaceAll(`<%- ${key} %>`, dataMap[key]);
    }

    return newHtml;
}


export default (options = {}) => {
    return {
        // 转换html的hooks
        transformIndexHtml: {
            // 控制执行时期的
            order: 'pre',
            // ctx 表示当前整个请求的执行期上下文：api/index.html ...
            // html: string,
            //     ctx: {
            //     path: string
            //     filename: string
            //     server?: ViteDevServer
            //     bundle?: import('rollup').OutputBundle
            //     chunk?: import('rollup').OutputChunk
            // },
            handler: (html, ctx) => transformHtmlHandler(html, options)
        }
    }
}

```

# 手写vite-plugin-mock

configureServer生命周期

就是拦截http请求

```js
// 拦截http请求
import fs from "fs";
import mockDescriptors from '../mock/index.js';

const defaultOptions = {
    enabled: process.env.NODE_ENV === 'development',
};

const createMiddleware = (options, isExistDir, isAvailable) => {
    return (req, res, next) => {
        const reqUrl = req.url;
        if (isExistDir && isAvailable) {
            const mockDescriptor = mockDescriptors.find((mockItem) => mockItem.url === reqUrl);
            mockDescriptor ? handleMockRequest(options, mockDescriptor, req, res) : next();
        } else {
            console.log(`[vite]: mock directory is not found`);
            next();
        }
    };
};

const handleMockRequest = (options, mockDescriptor, req, res) => {
    if (!options.enabled) {
        throw new Error(`[vite]: current environment is ${process.env.NODE_ENV}`);
    }
    const response = mockDescriptor.response({body: undefined}) || {};
    res.setHeader('Content-type', 'application/json');
    res.end(JSON.stringify(response));
};

export default (options = {}) => {
    const newOptions = {...defaultOptions, ...options};

    return {
        configureServer: (serve) => {
            const middleware = serve.middlewares;
            const isExistDir = fs.existsSync('mock/index.js');
            const isAvailable = Array.isArray(mockDescriptors) && mockDescriptors.length > 0;

            middleware.use(createMiddleware(newOptions, isExistDir, isAvailable));
        },
    };
};
```

