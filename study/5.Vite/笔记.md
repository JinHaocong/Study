# Vite

开箱即用：不需要做任何额外配置就可以使用vite来帮你处理构建工作

# 搭建一个Vite项目

初始化项目

```powershell
yarn init -y
```

安装一个测试包 lodash

```powershell
yarn add lodash
```

在根目录下创建 **index.html** **main.js**  

安装 Vite

```powershell
yarn add vite -D
```

package.json添加启动项

```json
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "test": "vite --mode test"
  },
```

运行

```
yarn dev
```

yarn dev => 开发环境

在处理过程中如果遇到非绝对路径或者相对路径的引用，他则会尝试开启路劲补全。

**生产环境下** vite 会全权交给一个叫 rollup 的库去完成生产环境的打包。

实际上vite在考虑另外一个问题的时候就顺便把这个问题就解决了。

common js规范的导出 modules.exports

有的包是以common js规范导出的，vite就不认识了

**依赖预构建**：首先vite会找到对应的依赖，然后调用esbuild（对js语法进行处理的一个库）将其他规范的代码转换成 esmodule规范 然后放到当前目录下的node_modules下的.vite/deps，同时对esmodule的各个模块进行统一集成。

依赖预构建解决了三个问题：

1. 不同的第三方包会有不同的导出格式，vite是无法约束的。
2. 对路径的处理，方便路径重写。
3. 网络多包传输的性能问题。

有了依赖预构建后 vite 会将他们集成一个或几个js模块

# vite.config.js vite处理文件

## 生产环境和开发环境配置

根目录创建vite.config.js

1. vite 配置文件的语法提示。

   - webstorm会语法补全
   - vscode会特殊处理

   下面两种方法都可以开启代码提示

   ```js
   /** @type import("vite").UserConfig */
   const viteConfig =  {
       optimizeDeps :{
           exclude:["lodash-es"],
       }
   }
   
   export default viteConfig
   ```

   ```js
   import  {defineConfig} from "vite";
   
   export default defineConfig({
       optimizeDeps:{
           exclude:["lodash-es"], // 依赖预构建
       }
   })
   ```

2. 关于环境的处理

   - 过去使用webpack的时候要区分配置文件的环境

     - webpack.dev.config
     - webpack.prod.config

   - 在vite中

     ```js
     import {defineConfig} from "vite";
     import viteBaseConfig from "./vite.base.config";
     import viteDevConfig from "./vite.dev.config";
     import viteProdConfig from "./vite.prod.config";
     
     // 策略模式
     const envResolver = {
         "build": () => {
             console.log('生产环境')
             return ({...viteBaseConfig, ...viteDevConfig})
         },
         "serve": () => {
             console.log('开发环境')
             return Object.assign({}, viteBaseConfig, viteProdConfig)
         },
     }
     
     
     // command : "build" | "serve"
     export default defineConfig(({command}) => {
         console.log(command, 'command')
     
         return envResolver[command]()
         // if (command === 'build') {
         //     // 代表生产环境的配置
         // } else {
         //     // 代表开发环境的配置
         // }
     })
     
     ```

## vite环境变量配置

**环境变量**：会根据当前代码产生值的变化的量叫做环境变量。

**代码环境**：

1. 开发环境
2. 生产环境
3. 测试环境
4. 预发布环境
5. 灰度环境

在vite中如何处理：会使用docenv三方库，docenv会自动读取.env文件，并解析文件中的对应环境变量，并将其注入到process对象下（但是，vite考虑到和其他配置的冲突问题，不会直接注入到process对象下，涉及到vite.config.js中的一些配置，root，envdir）

- evnDir：用来配置当前环境变量配置的文件地址

**补偿措施**，可以调用vite的lodaEnv来手动确认env文件

> 补充知识：为什么vite.config.js可以书写成esmodule的形式，是因为vite在读取vite.config.js的时候，会率node先去解析文件语法，如果是esmodule语法会将其替换成commonjs语法

```js
import {defineConfig, loadEnv} from "vite";
import viteBaseConfig from "./vite.base.config";
import viteDevConfig from "./vite.dev.config";
import viteProdConfig from "./vite.prod.config";

// 策略模式
const envResolver = {
    "build": () => {
        console.log('生产环境')
        return ({...viteBaseConfig, ...viteDevConfig})
    },
    "serve": () => {
        console.log('开发环境')
        return Object.assign({}, viteBaseConfig, viteProdConfig)
    },
}


// command : "build" | "serve"
// mode 即为 yarn dev --mode development （development可以修改成别的）
export default defineConfig(({command, mode}) => {
    // mode 当前env文件所在目录 env的文件名（.env为默认可以不传）
    const env = loadEnv(mode, process.cwd(), "")
    console.log(mode, 'mode')

    return envResolver[command]()
    // if (command === 'build') {
    //     // 代表生产环境的配置
    // } else {
    //     // 代表开发环境的配置
    // }
})

```

process.cwd()： 返回当前node进程的工作目录

- .env：所有环境都用到的环境变量
- .env.development：开发环境所需的环境变量（vite默认情况下开发环境取名为development）
- .env.production：生产环境所需的环境变量（vite默认情况下生产环境取名为production）
- .env.test：测试环境所需的环境变量（vite默认情况下测试环境取名为test）

当我们调用loadEnv时会做如下几件事：

- 直接找到.env文件，解析环境变量并放入对象里
- 会将传进来的mode这个变量的值进行拼接：```.env.development```，并根据我们提供的目录去取对应的配置文件进行解析放入对象，会覆盖掉之前读取的.env对象
  - const baseEnvConfig = 读取.env配置
  - const modeEnvConfig = 读取env相关配置
  - const lastEnvConfig = { ...baseEnvConfig , ...modeEnvConfig  }

**如果是客户端 vite 会将环境变量注入到import.meta.env中**

vite 做了一个拦截 为了防止将不必要的变量直接注入 import.meta.env，如果你的环境变量不是以vite开头的就不会注入到客户端中。如果想要更改这个前缀，可以在config中配置envPrefix

```js
import {defineConfig} from "vite";

export default defineConfig({
    optimizeDeps: {
        exclude: [],  // exclude:["lodash-es"] lodash-es不进行预构建
    },
    envPrefix: 'JHC', // 配置环境变量前缀
})

```

# vite 是如何让浏览器识别.vue文件的？

Vite 使用了一种基于浏览器原生模块系统的开发服务器，它使用了浏览器的 ESM（ECMAScript 模块）加载能力。在 Vite 中，`.vue` 文件的处理是通过 Vite 插件和浏览器的原生 ESM 功能实现的。

下面是 Vite 是如何让浏览器识别 `.vue` 文件的基本原理：

1. **Vite 插件：** Vite 使用了一个名为 `vite-plugin-vue` 的插件，该插件负责处理 `.vue` 文件。该插件会拦截 `.vue` 文件的导入，然后对其进行解析和转换。
2. **Vue 单文件组件（SFC）解析：** `.vue` 文件是 Vue 单文件组件，包含了模板、脚本和样式等部分。Vite 插件会解析 `.vue` 文件，提取出其中的模板、脚本和样式，并将它们分别作为独立的模块。
3. **动态导入：** Vite 利用浏览器原生的动态导入（Dynamic Import）功能。每当一个 `.vue` 文件被导入时，Vite 会将该文件拆分成单独的模块，并使用动态导入将这些模块引入到浏览器中。
4. **浏览器原生模块系统：** 现代浏览器支持原生的 ESM（ECMAScript 模块）加载，这使得浏览器可以以非常高效的方式加载模块。Vite 利用了这一特性，将拆分后的模块通过原生 ESM 在浏览器中加载和执行。

总体来说，Vite通过将Vue单文件组件拆分成原生的模块，并利用浏览器的原生模块系统加载这些模块，实现了对`.vue`文件的高效处理和加载。这种方式相较于传统的打包工具，可以更加快速地实现模块的按需加载。

# 在vite中处理css less等

vite天生就支持对css文件的处理

1. vite在读取到main.js中引用到了index.css。
2. 直接使用fs模块读取index.css中的内容。
3. 直接创建一个style标签，将样式内容插入。
4. 将style标签插入index.html的head中。
5. 将该css文件中的内容直接替换成js脚本（方便热更新，css模块化），同时设置content-type设置成js，从而让浏览器以js执行该css后缀文件。

类名重复会导致样式被覆盖，解决方法：

- cssmodule 将css名改成 xxx.module.css 它会将类命名根据一定规则进行替换

# vite配置中的css配置流程

## modules

配置模块化参数

- localConvention 修改生成对象key的展示形式（驼峰还是中划线）。

  - dashesOnly 只显示中划线
  - camelCase 驼峰和中划线都显示
  - camelCaseOnly 只显示驼峰命名

- scopeBehaviour配置当前的模块化行为是模块化还是全局化（有hash值就是开启了模块化的标志，因为可以产生不同的hash值，保证类名唯一不被覆盖）。
  - local 开启模块化，有hash值
  - global 关闭模块化
- generateScopedName 模块化生成的类名的规则，可以配置成函数，函数返回值为最终显示类名。
- hashPrefix 生成 hash 的时候会根据类名，和其他的字符串（如 文件名）生成，如果想要生成的 hash 更加复杂唯一，可以配置这个选项，会参与最终的 hash 生成
  - hash：只要字符串有一个字符不一样，生成的hash就会不一样。
- globalModulePaths 代表不想参与css模块化的路径

```js
import {defineConfig} from "vite";
export default defineConfig({
    optimizeDeps: {
        exclude: [],  // exclude:["lodash-es"] lodash-es不进行预构建
    },
    envPrefix: 'JHC', // 配置环境变量前缀
    css:{ // 对 css 的行为进行配置
        // 最终会丢给postcss-modules
        modules:{// 是对 css 模块化的默认行为进行覆盖
            localsConvention:"camelCase", // 修改生成对象key的展示形式（驼峰还是中划线）
            scopeBehaviour:"local", // 配置当前的模块化行为是模块化还是全局化
            generateScopedName:"[name]_[local]_[hash:6]", // 模块化生成的类名的规则 也可配置成函数
            // generateScopedName:(name,filename,css) => {
            //     // name => css 文件中的类名
            //     // filename => css 文件的绝对路径
            //     // css => css 文件中的样式
            //     // 返回值就是最终显示类名
            //     return `${name}`
            // },
            hashPrefix:"jhc", // 生成 hash 的时候会根据类名生成，如果想要生成的 hash 更加复杂唯一，可以配置这个选项，会参与最终的 hash 生成
            globalModulePaths:["./A.module.css"], // 代表不想参与css模块化的路径
        }
    }
})

```

## preprocessorOptions

配置css预处理器的一些全局参数

```js
import {defineConfig} from "vite";
export default defineConfig({
    optimizeDeps: {
        exclude: [],  // exclude:["lodash-es"] lodash-es不进行预构建
    },
    envPrefix: 'JHC', // 配置环境变量前缀
    css:{ // 对 css 的行为进行配置
        // 最终会丢给postcss-modules
        modules:{// 是对 css 模块化的默认行为进行覆盖
            localsConvention:"camelCase", // 修改生成对象key的展示形式（驼峰还是中划线）
            scopeBehaviour:"local", // 配置当前的模块化行为是模块化还是全局化
            generateScopedName:"[name]_[local]_[hash:6]", // 模块化生成的类名的规则 也可配置成函数
            // generateScopedName:(name,filename,css) => {
            //     // name => css 文件中的类名
            //     // filename => css 文件的绝对路径
            //     // css => css 文件中的样式
            //     // 返回值就是最终显示类名
            //     return `${name}`
            // },
            hashPrefix:"jhc", // 生成 hash 的时候会根据类名生成，如果想要生成的 hash 更加复杂唯一，可以配置这个选项，会参与最终的 hash 生成
            globalModulePaths:["./A.module.css"], // 代表不想参与css模块化的路径
        },
        preprocessorOptions:{
            // key + config key代表预处理器的名称
            less:{
                math:"always",
                // 全局变量
                globalVars:{
                    mainColor:"red"
                }
            },
            // sass:{
            //
            // }
        },
        // Sourcemap 代表文件之间的索引，为了展示正确的错误位置，源代码映射
        devSourcemap:true, // 开启 css 的 Sourcemap
    }
})

```

## postcss

和babel类似：降级执行js，让js执行起来万无一失。

会将一些高级语法 嵌套 函数 变量等 降级编译成原生css，前缀补全

vite天生对postcss有良好的支持，他的工作是保持css再执行起来是万无一失的，解决兼容性，预处理器并不能解决这些问题：

1. 降级使用css问题
2. 前缀补全 --webkit

使用postcss

1. 安装依赖

   ```
    yarn add postcss-cli postcss -D
   ```

2. 书写描述文件 postcss.config.js

   1. 安装插件

      ```
      yarn add postcss-preset-env -D
      ```

vite中postcss的配置

为什么postcss没有编译全局css变量？

使用的一些未来的css特性不需要less sass处理，只能交给postcss处理

## vite加载静态资源以及别名配置

vite对静态资源是开箱即用的

```js
import {defineConfig} from "vite";
import __ from "lodash/fp/__";
const postcssPresetEnv = require("postcss-preset-env");
const path = require("path");
export default defineConfig({
    optimizeDeps: {
        exclude: [],  // exclude:["lodash-es"] lodash-es不进行预构建
    },
    envPrefix: 'JHC', // 配置环境变量前缀
    css:{
        // 对 css 的行为进行配置
        // 最终会丢给postcss-modules
        modules:{// 是对 css 模块化的默认行为进行覆盖
            localsConvention:"camelCase", // 修改生成对象key的展示形式（驼峰还是中划线）
            scopeBehaviour:"local", // 配置当前的模块化行为是模块化还是全局化
            generateScopedName:"[name]_[local]_[hash:6]", // 模块化生成的类名的规则 也可配置成函数
            // generateScopedName:(name,filename,css) => {
            //     // name => css 文件中的类名
            //     // filename => css 文件的绝对路径
            //     // css => css 文件中的样式
            //     // 返回值就是最终显示类名
            //     return `${name}`
            // },
            hashPrefix:"jhc", // 生成 hash 的时候会根据类名生成，如果想要生成的 hash 更加复杂唯一，可以配置这个选项，会参与最终的 hash 生成
            // globalModulePaths:["./A.module.css"], // 代表不想参与css模块化的路径
        },
        preprocessorOptions:{
            // key + config key代表预处理器的名称
            less:{
                math:"always",
                // 全局变量
                globalVars:{
                    mainColor:"red"
                }
            },
            // sass:{
            //
            // }
        },
        // Sourcemap 代表文件之间的索引，为了展示正确的错误位置，源代码映射
        devSourcemap:true, // 开启 css 的 Sourcemap
        // 也可以在postcss.config.js中配置
        postcss:{
            plugins:[postcssPresetEnv({
                // 让postcss知道有一些全局变量他需要记下来
                importFrom:path.resolve(__dirname,'./variable.css')
            })]
        }
    },
    resolve:{
        // 别名
        alias:{
            "@":path.resolve(__dirname,'./src'),
            "@assets":path.resolve(__dirname,'./src/assets')
        }
    }
})

```

## resolve.alias别名原理

就是一个字符串替换

## 生产环境build配置

```js
import {defineConfig} from "vite";
import __ from "lodash/fp/__";
const postcssPresetEnv = require("postcss-preset-env");
const path = require("path");
export default defineConfig({
    optimizeDeps: {
        exclude: [],  // exclude:["lodash-es"] lodash-es不进行预构建
    },
    envPrefix: 'JHC', // 配置环境变量前缀
    css:{
        // 对 css 的行为进行配置
        // 最终会丢给postcss-modules
        modules:{// 是对 css 模块化的默认行为进行覆盖
            localsConvention:"camelCase", // 修改生成对象key的展示形式（驼峰还是中划线）
            scopeBehaviour:"local", // 配置当前的模块化行为是模块化还是全局化
            generateScopedName:"[name]_[local]_[hash:6]", // 模块化生成的类名的规则 也可配置成函数
            // generateScopedName:(name,filename,css) => {
            //     // name => css 文件中的类名
            //     // filename => css 文件的绝对路径
            //     // css => css 文件中的样式
            //     // 返回值就是最终显示类名
            //     return `${name}`
            // },
            hashPrefix:"jhc", // 生成 hash 的时候会根据类名生成，如果想要生成的 hash 更加复杂唯一，可以配置这个选项，会参与最终的 hash 生成
            // globalModulePaths:["./A.module.css"], // 代表不想参与css模块化的路径
        },
        preprocessorOptions:{
            // key + config key代表预处理器的名称
            less:{
                math:"always",
                // 全局变量
                globalVars:{
                    mainColor:"red"
                }
            },
            // sass:{
            //
            // }
        },
        // Sourcemap 代表文件之间的索引，为了展示正确的错误位置，源代码映射
        devSourcemap:true, // 开启 css 的 Sourcemap
        // 也可以在postcss.config.js中配置
        postcss:{
            plugins:[postcssPresetEnv({
                // 让postcss知道有一些全局变量他需要记下来
                importFrom:path.resolve(__dirname,'./variable.css')
            })]
        }
    },
    resolve:{
        // 别名
        alias:{
            "@":path.resolve(__dirname,'./src'),
            "@assets":path.resolve(__dirname,'./src/assets')
        }
    },
    build:{
        // 配置 rollup 的构建策略
        rollupOptions:{
            // 控制输出
            output:{
                assetFileNames:"[hash:10].[name].[ext]"
            }
        },
        // 低于 4kb b的会被打包成base64
        assetsInlineLimit:4096,
        // 输出目录
        outDir:"dist",
        // 输出静态资源目录
        assetsDir:"static"
    }
})

```

# vite插件

允许vite在不同的生命周期调用不同的插件以达到不同的目的。

vite内置了非常多的核心插件。

vite也继承了vue团队一贯的作风，尽可能的开箱即用。

## vite-aliases自动生成别名

会检测包括src在内的所有文件夹并帮助我们生成别名

```powershell
yarn add vite-aliases -D
```

```js
import {defineConfig} from "vite";
import path from "path";
import {ViteAliases} from 'vite-aliases'
import postcssPresetEnv from 'postcss-preset-env'

export default defineConfig({
    optimizeDeps: {
        exclude: [],  // exclude:["lodash-es"] lodash-es不进行预构建
    },
    envPrefix: 'JHC', // 配置环境变量前缀
    css: {
        // 对 css 的行为进行配置
        // 最终会丢给postcss-modules
        modules: {// 是对 css 模块化的默认行为进行覆盖
            localsConvention: "camelCase", // 修改生成对象key的展示形式（驼峰还是中划线）
            scopeBehaviour: "local", // 配置当前的模块化行为是模块化还是全局化
            generateScopedName: "[name]_[local]_[hash:6]", // 模块化生成的类名的规则 也可配置成函数
            // generateScopedName:(name,filename,css) => {
            //     // name => css 文件中的类名
            //     // filename => css 文件的绝对路径
            //     // css => css 文件中的样式
            //     // 返回值就是最终显示类名
            //     return `${name}`
            // },
            hashPrefix: "jhc", // 生成 hash 的时候会根据类名生成，如果想要生成的 hash 更加复杂唯一，可以配置这个选项，会参与最终的 hash 生成
            // globalModulePaths:["./A.module.css"], // 代表不想参与css模块化的路径
        },
        preprocessorOptions: {
            // key + config key代表预处理器的名称
            less: {
                math: "always",
                // 全局变量
                globalVars: {
                    mainColor: "red"
                }
            },
            // sass:{
            //
            // }
        },
        // Sourcemap 代表文件之间的索引，为了展示正确的错误位置，源代码映射
        devSourcemap: true, // 开启 css 的 Sourcemap
        // 也可以在postcss.config.js中配置
        postcss: {
            plugins: [
                postcssPresetEnv({
                    // 让postcss知道有一些全局变量他需要记下来 最新版已启用该字段
                    importFrom: path.resolve(__dirname, './variable.css')
                }),
            ]
        }
    },
    resolve: {
        // 别名
        // alias: {
        //     "@": path.resolve(__dirname, './src'),
        //     "@assets": path.resolve(__dirname, './src/assets')
        // }
    },
    build: {
        // 配置 rollup 的构建策略
        rollupOptions: {
            // 控制输出
            output: {
                assetFileNames: "[hash:10].[name].[ext]"
            }
        },
        // 低于 4kb b的会被打包成base64
        assetsInlineLimit: 4096,
        // 输出目录
        outDir: "dist",
        // 输出静态资源目录
        assetsDir: "assets",
    },
    plugins: [
        ViteAliases({
            prefix: '@'
        })
    ]
})

```

## 手写vite-aliases

需要在vite执行配置文件之前去改写配置文件，所以在`config`钩子中调用

ViteAliases.js中

```js
// vite的插件必须返回给vite一个配置对象

import path from "path";
import fs from "fs";


// 过滤掉文件 只保留目录
// 过滤掉文件，只保留目录
function filterDirectories(files, basePath) {
    return files.filter((fileName) => {
        // fs.statSync 方法用于获取文件的状态信息，包括文件类型、大小、创建时间等。
        const fileStat = fs.statSync(path.join(basePath, fileName));
        // 只返回目录
        return fileStat.isDirectory();
    });
}


// 获取别名配置对象
function getAliasOptions(prefix, basePath) {
    const result = filterDirectories(fs.readdirSync(basePath), basePath);

    const aliasObj = {
        [prefix]: basePath,
    };

    result.forEach((dir) => {
        aliasObj[`${prefix}${dir}`] = path.join(basePath, dir);
    });

    return aliasObj;
}


export default ({prefix}) => {
    return {
        // config 返回的配置对象会覆盖掉原有的配置
        config(config, env) {
            // config: UserConfig
            // env: { mode: string, command: string })
            // mode: development production
            // command: build dev
            const srcPath = path.join(__dirname, '../src');
            const aliasOptions = getAliasOptions(prefix, srcPath);

            return {
                resolve: {
                    alias: aliasOptions,
                },
            }
        }
    }
}

```

## vite-plugin-html动态控制html文件中的内容

- HTML 压缩能力
- EJS 模版能力
- 多页应用支持
- 支持自定义`entry`
- 支持自定义`template`

```powershell
yarn add vite-plugin-html -D
```

```js
import {defineConfig} from "vite";
import path from "path";
// import {ViteAliases} from 'vite-aliases'
import ViteAliases from "./plugins/ViteAliases.js"
import postcssPresetEnv from 'postcss-preset-env'
import {createHtmlPlugin} from 'vite-plugin-html'

export default defineConfig({
    base: './',
    optimizeDeps: {
        exclude: [],  // exclude:["lodash-es"] lodash-es不进行预构建
    },
    envPrefix: 'JHC', // 配置环境变量前缀
    css: {
        // 对 css 的行为进行配置
        // 最终会丢给postcss-modules
        modules: {// 是对 css 模块化的默认行为进行覆盖
            localsConvention: "camelCase", // 修改生成对象key的展示形式（驼峰还是中划线）
            scopeBehaviour: "local", // 配置当前的模块化行为是模块化还是全局化
            generateScopedName: "[name]_[local]_[hash:6]", // 模块化生成的类名的规则 也可配置成函数
            // generateScopedName:(name,filename,css) => {
            //     // name => css 文件中的类名
            //     // filename => css 文件的绝对路径
            //     // css => css 文件中的样式
            //     // 返回值就是最终显示类名
            //     return `${name}`
            // },
            hashPrefix: "jhc", // 生成 hash 的时候会根据类名生成，如果想要生成的 hash 更加复杂唯一，可以配置这个选项，会参与最终的 hash 生成
            // globalModulePaths:["./A.module.css"], // 代表不想参与css模块化的路径
        },
        preprocessorOptions: {
            // key + config key代表预处理器的名称
            less: {
                math: "always",
                // 全局变量
                globalVars: {
                    mainColor: "red"
                }
            },
            // sass:{
            //
            // }
        },
        // Sourcemap 代表文件之间的索引，为了展示正确的错误位置，源代码映射
        devSourcemap: true, // 开启 css 的 Sourcemap
        // 也可以在postcss.config.js中配置
        postcss: {
            plugins: [
                postcssPresetEnv({
                    // 让postcss知道有一些全局变量他需要记下来 最新版已启用该字段
                    importFrom: path.resolve(__dirname, './variable.css')
                }),
            ]
        }
    },
    resolve: {
        // 别名
        // alias: {
        //     "@": path.resolve(__dirname, './src'),
        //     "@assets": path.resolve(__dirname, './src/assets'),
        //     "@components": path.resolve(__dirname, './src/components')
        // }
    },
    build: {
        // 配置 rollup 的构建策略
        rollupOptions: {
            // 控制输出
            output: {
                // 默认值 "assets/[name]-[hash][extname]"
                assetFileNames: "assets/[hash:10].[name][extname]",
            }
        },
        // 低于 4kb b的会被打包成base64
        assetsInlineLimit: 4096,
        // 输出目录
        outDir: "dist",
        // 输出静态资源目录
        assetsDir: "assets",
        // 启用 CSS 代码拆分
        cssCodeSplit: true
    },
    plugins: [
        ViteAliases({
            prefix: '@'
        }),
        createHtmlPlugin({
            // 压缩html
            minify: true,
            /**
             * 在这里写entry后，你将不需要在`index.html`内添加 script 标签，原有标签需要删除
             * @default src/main.ts
             */
            entry: 'main.js',
            /**
             * 如果你想将 `index.html`存放在指定文件夹，可以修改它，否则不需要配置
             * @default index.html
             */
            template: 'index.html',

            /**
             * 需要注入 index.html ejs 模版的数据
             */
            inject: {
                data: {
                    title: '首页',   // 出现在模版中的 <%- title %>
                    // injectScript: `<script src="./inject.js"></script>`, // 出现在模版中的<%- injectScript %>
                },
            },
        })
    ]
})

```

## 手写vite-plugin-html的inject data功能

在HtmlPlugin中

```js
function transformHtmlHandler(html, options) {
    const dataMap = (options.inject && options.inject.data) || {};
    let newHtml = html;

    for (const key in dataMap) {
        newHtml = newHtml.replaceAll(`<%- ${key} %>`, dataMap[key]);
    }

    return newHtml;
}


export default (options = {}) => {
    return {
        // 转换html的hooks
        transformIndexHtml: {
            // 控制执行时期的
            order: 'pre',
            // ctx 表示当前整个请求的执行期上下文：api/index.html ...
            // html: string,
            //     ctx: {
            //     path: string
            //     filename: string
            //     server?: ViteDevServer
            //     bundle?: import('rollup').OutputBundle
            //     chunk?: import('rollup').OutputChunk
            // },
            handler: (html, ctx) => transformHtmlHandler(html, options)
        }
    }
}

```

## vite-plugin-mock

模拟数据

mock/index.js

```js
import mockJS from "mockjs";

const userList = mockJS.mock({
    "data|100": [
        {
            name: "@cname", // 生成不同的中文名
            "id|+1": 1, // 自增
            time: "@time"
        }
    ]
})

export default [
    {
        method: "post",
        url: "/api/users",
        response: ({body}) => {

            return {
                code: 200,
                message: 'success',
                data: userList,
            }
        },
        headers: {
            'Content-Type': 'application/json'
        }
    }
]

```

vite.base.config.js

```js
import {defineConfig} from "vite";
import path from "path";
// import {ViteAliases} from 'vite-aliases'
import ViteAliases from "./plugins/ViteAliases.js"
import postcssPresetEnv from 'postcss-preset-env'
import {createHtmlPlugin} from 'vite-plugin-html'
// import HtmlPlugin from "./plugins/HtmlPlugin.js";
import {viteMockServe} from 'vite-plugin-mock'
import MockPlugin from "./plugins/MockPlugin.js";

export default defineConfig(
    {
        base: './',
        optimizeDeps: {
            exclude: [],  // exclude:["lodash-es"] lodash-es不进行预构建
        },
        envPrefix: 'JHC', // 配置环境变量前缀
        css: {
            // 对 css 的行为进行配置
            // 最终会丢给postcss-modules
            modules: {// 是对 css 模块化的默认行为进行覆盖
                localsConvention: "camelCase", // 修改生成对象key的展示形式（驼峰还是中划线）
                scopeBehaviour: "local", // 配置当前的模块化行为是模块化还是全局化
                generateScopedName: "[name]_[local]_[hash:6]", // 模块化生成的类名的规则 也可配置成函数
                // generateScopedName:(name,filename,css) => {
                //     // name => css 文件中的类名
                //     // filename => css 文件的绝对路径
                //     // css => css 文件中的样式
                //     // 返回值就是最终显示类名
                //     return `${name}`
                // },
                hashPrefix: "jhc", // 生成 hash 的时候会根据类名生成，如果想要生成的 hash 更加复杂唯一，可以配置这个选项，会参与最终的 hash 生成
                // globalModulePaths:["./A.module.css"], // 代表不想参与css模块化的路径
            },
            preprocessorOptions: {
                // key + config key代表预处理器的名称
                less: {
                    math: "always",
                    // 全局变量
                    globalVars: {
                        mainColor: "red"
                    }
                },
                // sass:{
                //
                // }
            },
            // Sourcemap 代表文件之间的索引，为了展示正确的错误位置，源代码映射
            devSourcemap: true, // 开启 css 的 Sourcemap
            // 也可以在postcss.config.js中配置
            postcss: {
                plugins: [
                    postcssPresetEnv({
                        // 让postcss知道有一些全局变量他需要记下来 最新版已启用该字段
                        importFrom: path.resolve(__dirname, './variable.css')
                    }),
                ]
            }
        },
        resolve: {
            // 别名
            // alias: {
            //     "@": path.resolve(__dirname, './src'),
            //     "@assets": path.resolve(__dirname, './src/assets'),
            //     "@components": path.resolve(__dirname, './src/components')
            // }
        },
        build: {
            // 配置 rollup 的构建策略
            rollupOptions: {
                // 控制输出
                output: {
                    // 默认值 "assets/[name]-[hash][extname]"
                    assetFileNames: "assets/[hash:10].[name][extname]",
                }
            },
            // 低于 4kb b的会被打包成base64
            assetsInlineLimit: 4096,
            // 输出目录
            outDir: "dist",
            // 输出静态资源目录
            assetsDir: "assets",
            // 启用 CSS 代码拆分
            cssCodeSplit: true
        },
        plugins: [
            ViteAliases({
                prefix: '@'
            }),
            createHtmlPlugin({
                // 压缩html
                minify: true,
                /**
                 * 在这里写entry后，你将不需要在`index.html`内添加 script 标签，原有标签需要删除
                 * @default src/main.ts
                 */
                entry: 'main.js',
                /**
                 * 如果你想将 `index.html`存放在指定文件夹，可以修改它，否则不需要配置
                 * @default index.html
                 */
                template: 'index.html',

                /**
                 * 需要注入 index.html ejs 模版的数据
                 */
                inject: {
                    data: {
                        title: '首页',   // 出现在模版中的 <%- title %>
                        // injectScript: `<script src="./inject.js"></script>`, // 出现在模版中的<%- injectScript %>
                    },
                },
            }),
            // HtmlPlugin({
            //     inject: {
            //         data: {
            //             title: '首页',   // 出现在模版中的 <%- title %>
            //             // injectScript: `<script src="./inject.js"></script>`, // 出现在模版中的<%- injectScript %>
            //         },
            //     },
            // }),
            viteMockServe({
                mockPath: 'mock',
            }),
            MockPlugin({})
        ]
    }
)

```

## 手写vite-plugin-mock

原理就是通过configureServer生命周期，拦截http请求。

```js
// 拦截http请求
import fs from "fs";
import mockDescriptors from '../mock/index.js';

const defaultOptions = {
    enabled: process.env.NODE_ENV === 'development',
};

const createMiddleware = (options, isExistDir, isAvailable) => {
    return (req, res, next) => {
        const reqUrl = req.url;
        if (isExistDir && isAvailable) {
            const mockDescriptor = mockDescriptors.find((mockItem) => mockItem.url === reqUrl);
            mockDescriptor ? handleMockRequest(options, mockDescriptor, req, res) : next();
        } else {
            console.log(`[vite]: mock directory is not found`);
            next();
        }
    };
};

const handleMockRequest = (options, mockDescriptor, req, res) => {
    if (!options.enabled) {
        throw new Error(`[vite]: current environment is ${process.env.NODE_ENV}`);
    }
    const response = mockDescriptor.response({body: undefined}) || {};
    res.setHeader('Content-type', 'application/json');
    res.end(JSON.stringify(response));
};

export default (options = {}) => {
    const newOptions = {...defaultOptions, ...options};

    return {
        configureServer: (serve) => {
            const middleware = serve.middlewares;
            const isExistDir = fs.existsSync('mock/index.js');
            const isAvailable = Array.isArray(mockDescriptors) && mockDescriptors.length > 0;

            middleware.use(createMiddleware(newOptions, isExistDir, isAvailable));
        },
    };
};
```