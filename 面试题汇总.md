# JavaScript

## 事件循环机制

**事件循环：**js是单线程的，但是有需要一种机制来处理多个块的执行，且执行每个块时调用js引擎，这种机制称为事件循环机制。

**事件循环三个部分：**主线程，宏队列，微队列，异步代码都会被丢尽宏/微队列

**宏任务：**script，setTimeout，setInterval，setImmediate，I/O，UI，rendering

**微任务：**nextTick，promise.then，object.observe

**主线程只有一个且执行的顺序为：**

1. 先执行主线程
2. 遇到宏任务放到宏任务队列
3. 遇到微任务放到微任务队列
4. 主线程执行完毕
5. 执行微任务队列
6. 执行一次宏任务队列，遇到微任务再次放到微任务队列中
7. 再执行微任务队列
8. 依次循环

## 闭包

什么是闭包？

1. 函数内返回一个函数
2. 函数声明的作用域和函数使用的作用域不同

用途？

1. 防抖
2. 节流
3. 获取私有作用域中的变量


JavaScript的闭包（Closure）是指在函数内部创建的函数，该函数可以访问其外部函数的作用域中的变量和参数，即使外部函数已经执行结束并返回。换句话说，闭包可以“记住”并访问其词法作用域，即在定义时所处的作用域，而不是调用时所处的作用域。

闭包通常由两个组成部分构成：

1. **内部函数**：在外部函数内部定义的函数。
2. **外部函数的环境**：内部函数可以访问外部函数的作用域及其中的变量、参数等。

下面是一个简单的示例，演示了闭包的概念：

```js
function outerFunction() {
  var outerVariable = 'I am from outer function';
  
  function innerFunction() {
    console.log(outerVariable); // 内部函数访问外部函数的变量
  }
  
  return innerFunction;
}

var closureFunction = outerFunction(); // 外部函数执行，返回内部函数
closureFunction(); // 调用闭包函数，输出：I am from outer function
```

在这个例子中，`innerFunction` 是一个闭包，它可以访问外部函数 `outerFunction` 的作用域中的变量 `outerVariable`，即使 `outerFunction` 已经执行结束并返回。通过将 `innerFunction` 赋值给 `closureFunction`，我们创建了一个闭包，可以在稍后的任何时间调用它，并且它仍然可以访问到外部函数的作用域。

闭包在 JavaScript 中有着广泛的应用，常用于模块化编程、封装私有变量和创建函数工厂等场景

## 垃圾回收机制

JavaScript的垃圾回收机制是一种自动管理内存的机制，它负责检测不再使用的内存，并释放这些内存以便重用。JavaScript中的垃圾回收机制主要基于两种策略：标记清除和引用计数。

1. **标记清除（Mark and Sweep）**：这是 JavaScript 最常见的垃圾回收策略。它通过标记不再使用的对象，然后清除（释放）这些对象所占用的内存。垃圾回收器会从根对象开始遍历内存中的对象，标记所有可以访问到的对象，然后清除那些没有被标记的对象。
2. **引用计数（Reference Counting）**：在引用计数策略中，每个对象都会有一个引用计数器。当对象被引用时，计数器加一；当对象不再被引用时，计数器减一。当计数器为零时，说明对象不再被引用，即可被垃圾回收。然而，引用计数策略会存在循环引用的问题，即两个或多个对象相互引用，导致它们的计数器永远不会为零，因此这种策略通常不会单独使用，而是与其他策略结合使用。

JavaScript引擎的垃圾回收器会周期性地检查不再被引用的对象，并将其释放。这个过程通常是自动的，开发人员不需要手动管理内存。但在某些情况下，比如在处理大量数据或者长时间运行的脚本中，了解和优化内存使用仍然是重要的。

# Vue

## vue模板编译的原理是什么

Vue 模板编译的原理可以分为以下几个步骤：

1. **解析：**首先，Vue 会将模板字符串解析成抽象语法树（AST）。AST 是一种树状结构，用于表示代码的抽象语法结构，它将模板字符串分解为一系列的节点，每个节点表示模板中的一个语法结构，比如元素、属性、文本内容等。
2. **静态分析：**在解析的过程中，Vue 还会进行静态分析，即分析模板中的静态内容，例如标签、属性、文本等，以及动态内容，例如表达式、指令等。静态内容是指在模板编译阶段就已经确定的内容，而动态内容是指需要在运行时根据数据进行计算得出的内容。
3. **优化：**Vue 在静态分析的基础上，会进行一些优化操作，例如静态节点的标记、静态属性的提升等，以提高渲染性能。
4. **代码生成：**根据 AST，Vue 会生成可执行的渲染函数。这个渲染函数是一个 JavaScript 函数，接受数据作为参数，返回虚拟 DOM。渲染函数中会包含对模板中动态内容的处理逻辑，以及对静态内容的渲染代码。
5. **渲染：**在运行时，Vue 会调用渲染函数，根据数据生成虚拟 DOM，并通过虚拟 DOM 进行 DOM 的更新。

总的来说，Vue 模板编译的原理是将模板字符串解析成 AST，进行静态分析和优化，然后生成可执行的渲染函数，最终通过渲染函数生成虚拟 DOM，实现模板到真实 DOM 的渲染过程。这个过程将动态的数据和静态的模板内容结合起来，实现了数据驱动视图的更新。

其中 

- `$mount`函数重点在于判断各属性的有无情况，还有记得返回Vue实例，便于后续访问实例

- `compileToFunctions`函数是`模板编译`的`入口函数`，包含`parse`和`generate`的执行，返回值是一个render函数
- `parse`函数（将template转为抽象语法树）
  - 首先需要各种规则匹配的正则表达式（开始标签，结束标签，花括号等）
  - createASTElement：将某一节点转为AST对象的函数
  - handleStartTag: 处理开始标签的函数
  - handleEndTag：处理结尾标签的函数
  - handleChars：处理文本节点的函数
  - parse：转AST的入口函数
- `generate`（将AST转换成render函数格式的数据）
  - 匹配花括号{{xxx}}
  - 确保AST解析成render函数所需格式

## vue初次渲染原理是什么

Vue 初次渲染的原理可以简单概括为以下步骤：

1. **准备阶段：**在初始化 Vue 实例时，Vue 会对组件进行实例化，并进行一系列的初始化操作，包括数据响应式的初始化、模板编译、虚拟 DOM 的生成等。
2. **模板编译：**Vue 在准备阶段会将模板字符串编译成渲染函数。这个过程包括将模板解析为抽象语法树（AST）、静态分析和优化、生成渲染函数等。
3. **虚拟 DOM 的生成：**根据编译得到的渲染函数，Vue 会在初次渲染时调用该函数生成虚拟 DOM（Virtual DOM）树。虚拟 DOM 是一个 JavaScript 对象树，它描述了真实 DOM 的结构。
4. **真实 DOM 的创建和挂载：**通过虚拟 DOM，Vue 会创建真实 DOM，并将其挂载到页面的指定位置。这个过程包括创建实际的 DOM 元素， patch函数（将虚拟DOM转真实DOM并渲染，并将其添加到页面中，形成初次渲染的 DOM 结构。
5. **数据的填充和绑定：**在初次渲染过程中，Vue 会将数据与模板进行绑定，将数据填充到对应的 DOM 元素中，完成页面的初次渲染。
6. **侦听器的建立：**在初次渲染完成后，Vue 会建立各种数据侦听器，用于监听数据的变化，并在数据变化时更新视图。

总的来说，Vue 初次渲染的过程是将模板编译成渲染函数，根据渲染函数生成虚拟 DOM，然后将虚拟 DOM 转换成真实 DOM 并挂载到页面上，最后填充数据完成初次渲染。这个过程实现了数据驱动视图的目标，使得视图能够随着数据的变化而自动更新。

## computed和watch的原理分别是什么?

`computed` 和 `watch` 都是 Vue 中用于处理数据响应式的工具，但它们的原理和使用方式有所不同。

1. **computed 的原理：**
   - `computed` 是一个计算属性，它的值是根据依赖的数据动态计算而来的，只有当依赖的数据发生变化时，`computed` 的值才会重新计算。
   - `computed` 的原理是利用了 Vue 的响应式系统。当定义一个计算属性时，Vue 会将这个计算属性转化为一个响应式的属性，同时建立对依赖数据的监听。
   - 当依赖数据发生变化时，Vue 会检测到变化并触发计算属性的重新计算，然后缓存计算结果。在接下来的访问中，如果依赖数据没有变化，Vue 会直接返回缓存的计算结果，而不会重新计算。
2. **watch 的原理：**
   - `watch` 是一个侦听器，用于监听指定数据的变化，并在数据变化时执行指定的回调函数。
   - `watch` 的原理是利用了 Vue 的观察者模式。当定义一个 `watch` 时，Vue 会创建一个观察者对象，该观察者对象会监听指定的数据，并在数据变化时执行指定的回调函数。
   - 当监听的数据发生变化时，观察者对象会收到通知，并执行指定的回调函数，从而实现对数据变化的响应。

总的来说，`computed` 的原理是基于依赖数据的动态计算，而 `watch` 的原理是基于数据变化的观察和响应。`computed` 适用于根据其他数据动态计算出一个值的场景，而 `watch` 适用于需要在数据变化时执行自定义逻辑的场景。

## nextTick是做什么的，他的原理是什么?

`nextTick` 是 Vue 中提供的一个异步更新队列处理工具，用于在 DOM 更新之后执行延迟的操作。它的主要作用是在当前更新周期结束之后执行回调函数，从而确保能够在 DOM 更新之后进行一些操作，比如获取更新后的 DOM 元素或执行一些依赖于 DOM 的操作。

`nextTick` 的主要原理是利用了 JavaScript 的事件循环机制。在 Vue 中，当数据发生变化时，Vue 会将数据变更的更新操作放入一个队列中，然后等待当前的同步代码执行完毕后，再进行异步更新队列的处理。而 `nextTick` 就是利用了这个队列，在队列的下一个 tick（即下一个事件循环）中执行指定的回调函数。

具体来说，`nextTick` 的原理包括以下几个步骤：

1. 将回调函数放入一个异步队列中，等待当前执行栈中的代码执行完毕。

2. 等待当前执行栈中的同步代码执行完毕后，进入事件循环的下一个 tick。

3. 在下一个 tick 中，执行异步队列中的回调函数。

这样，就能够确保在 DOM 更新之后执行指定的回调函数，从而保证了数据更新后的一致性和正确性。

总的来说，`nextTick` 的原理是利用 JavaScript 的事件循环机制，在当前更新周期结束之后执行延迟的操作，从而确保能够在 DOM 更新之后进行一些操作。

## set是做什么的，原理是什么?

在 Vue.js 中，`Vue.set` 是一个用于添加响应式属性到 Vue 实例的方法。它主要用于在运行时向响应式对象添加新的属性，以确保这些属性也是响应式的，即当添加新属性后，Vue 能够监听到该属性的变化并触发视图更新。

`Vue.set` 的主要作用是解决 Vue 在监听对象属性时的一个限制：Vue 不能检测到对象的属性的添加或删除。当直接使用 `obj.prop = value` 的方式添加属性时，Vue 无法监听到这个新属性的变化，因此不会触发视图更新。为了解决这个问题，Vue 提供了 `Vue.set` 方法来手动添加响应式属性。

`Vue.set` 方法接受三个参数：要添加属性的对象、属性名和属性值。当调用 `Vue.set(obj, 'prop', value)` 时，Vue 会确保 `obj` 的 `prop` 属性是响应式的，即使该属性之前不存在。

`Vue.set` 的原理是利用了 Vue 内部的响应式系统。当调用 `Vue.set` 方法添加属性时，Vue 会对指定对象进行递归遍历，并对新增的属性进行侦测和劫持，从而确保新增的属性也能够被 Vue 监听到变化并触发相应的更新操作。

总的来说，`Vue.set` 的作用是向 Vue 实例的响应式对象添加新属性，使其也能够被 Vue 监听到变化并触发视图更新，其原理是利用 Vue 的响应式系统来实现属性的侦测和劫持。

## observable是做什么的，原理是什么？

`Vue.observable` 是 Vue.js 提供的一个用于创建响应式数据的函数。它的作用是将一个普通的 JavaScript 对象转换为响应式的对象，使得当对象的属性发生变化时，能够自动触发相应的视图更新。

`Vue.observable` 的原理是利用了 Vue 内部的响应式系统。当调用 `Vue.observable(obj)` 方法时，Vue 会对传入的对象 `obj` 进行递归遍历，并使用 `Object.defineProperty` 或 `Proxy` 等技术对对象的每个属性进行劫持或代理，从而使得这些属性能够被 Vue 监听到变化。

具体来说，`Vue.observable` 的原理大致分为以下几个步骤：

1. 对传入的对象进行遍历，对每个属性进行劫持或代理操作。
   
2. 对象的每个属性被访问时，通过 `getter` 函数收集依赖，从而建立属性与观察者之间的关联关系。

3. 对象的每个属性被修改时，通过 `setter` 函数触发更新，从而通知相关的观察者进行视图更新。

4. 当对象的属性被删除时，Vue 会删除与之相关的依赖关系，以确保不再监听到该属性的变化。

总的来说，`Vue.observable` 的原理是将普通的 JavaScript 对象转换为一个可以被 Vue 监听到变化并触发视图更新的响应式对象，实现了数据与视图之间的绑定。这种响应式的实现方式是 Vue 框架的核心之一，也是 Vue 的数据驱动视图更新的基础。

## vue的use是做什么的，原理是什么？

`Vue.use` 是 Vue.js 提供的一个全局方法，用于安装 Vue.js 插件。它的作用是将插件注册到 Vue.js 实例中，从而扩展 Vue.js 的功能。通常用于在 Vue.js 应用中使用第三方库或自定义功能。

`Vue.use` 的原理是比较简单的，它实际上就是调用插件对象的 `install` 方法，并将 Vue 构造函数作为参数传递给 `install` 方法。在 `install` 方法中，可以执行一些初始化操作，并且可以在 Vue 原型上挂载一些全局的方法、指令、过滤器等。

具体来说，`Vue.use` 的原理大致分为以下几个步骤：

1. 调用插件对象的 `install` 方法，并将 Vue 构造函数作为参数传递给 `install` 方法。
2. 在 `install` 方法中执行一些初始化操作，例如注册全局组件、指令、过滤器等。
3. 将插件的功能注册到 Vue.js 实例中，使得这些功能可以在 Vue.js 应用中使用。

## vue2和vue3中v-for 和 v-if 的优先级是怎样的？

- **Vue2 中 v-for 优先级比 v-if 高**
- **Vue3 中 v-if 优先级比 v-for 高**

总结：
在v-for和v-if共存的情况下

- Vue2中会先走循环，在循环过程中进行条件的判断，最终会导致性能浪费（v-for优先级高于v-if）。
- Vue3中则会先走判断，满足条件再走循环，但会出现item找不到情况，建议做法是将v-if的条件判断抽到computed中使用filter函数进行过滤处理（v-if优先级高于v-for)

## vue2与vue3区别有哪些？优缺点有哪些？

### 1、双向数据绑定原理不同

**vue2**：vue2的双向数据绑定是利用**ES5的一个APIObject.definePropert()** 对数据进行劫持，结合发布订阅模式的方式来实现的。

**vue3**：vue3中使用了**ES6的Proxy API**对数据代理。相比vue2.x，使用proxy的优势如下：

- defineProperty只能监听某个属性，不能对全对象监听
- 可以省去for in，闭包等内容来提升效率(直接绑定整个对象即可)
- 可以监听数组，不用再去单独的对数组做特异性操作vue3.x可以检测到数组内部数据的变化。

### 2、是否支持碎片

**vue2**：vue2**不支持**碎片。

**vue3**：vue3**支持碎片（Fragments）** ，就是说可以拥有多个根节点。

### 3、API类型不同

**vue2**：vue2使用**选项类型api**，选项型api在代码里分割了不同的属性：data,computed,methods等。

**vue3**：vue3使用**合成型api**，新的合成型api能让我们使用方法来分割，相比于旧的api使用属性来分组，这样代码会更加简便和整洁。

### 4、定义数据变量和方法不同

**vue2**：vue2是把数据放入data中，在vue2中定义数据变量是**data(){}** ，创建的方法要在**methods:{}** 中。

**vue3**：，vue3就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。使用以下三个步骤来建立反应性数据：

- 从vue引入**reactive**；
- 使用**reactive()** 方法来声明数据为响应性数据；
- 使用setup()方法来返回我们的响应性数据，从而**template**可以获取这些响应性数据。

### 5、生命周期钩子函数不同

**vue2**：**vue2中的生命周期**：

- beforeCreate 组件创建之前
- created 组件创建之后
- beforeMount 组价挂载到页面之前执行
- mounted 组件挂载到页面之后执行
- beforeUpdate 组件更新之前
- updated 组件更新之后

**vue3**：**vue3中的生命周期**：

- setup 开始创建组件
- onBeforeMount 组价挂载到页面之前执行
- onMounted 组件挂载到页面之后执行
- onBeforeUpdate 组件更新之前
- onUpdated 组件更新之后

而且vue3.x 生命周期在调用前需要先进行引入。除了这些钩子函数外，vue3.x还增加了onRenderTracked 和onRenderTriggered函数。

## vue2与vue3的响应式原理分别是什么？有什么不同？

在 Vue 2 和 Vue 3 中，响应式原理都是用于实现数据与视图的双向绑定，但它们的具体实现方式有所不同。

**Vue 2 的响应式原理：**

在 Vue 2 中，Vue 使用了基于 `Object.defineProperty` 的响应式系统。当一个对象被传入 Vue 实例的 `data` 选项中时，Vue 会递归遍历对象的每个属性，并使用 `Object.defineProperty` 将每个属性转换为 getter 和 setter。这样一来，当属性被访问时，Vue 能够捕获依赖关系，并在属性被修改时通知相关的依赖进行更新。

**Vue 3 的响应式原理：**

在 Vue 3 中，Vue 使用了基于 `Proxy` 的响应式系统。相比于 Vue 2 中的 `Object.defineProperty`，`Proxy` 提供了更强大和灵活的拦截器功能，能够捕获更多的操作，例如属性的删除、数组的变动等。这使得 Vue 3 的响应式系统更加现代化、简洁和高效。

**不同之处：**

1. **实现方式：** Vue 2 使用了 `Object.defineProperty`，而 Vue 3 使用了 `Proxy`。
2. **性能差异：** 由于 `Proxy` 的拦截器功能更强大，Vue 3 的响应式系统相对于 Vue 2 有一定的性能提升，尤其是在处理大型数据集合或数组变动时。
3. **API 变化：** 由于响应式系统的变化，Vue 3 中的一些 API 可能与 Vue 2 不兼容，例如在使用 `Vue.set` 或 `this.$set` 时的行为可能会有所不同。

总的来说，Vue 3 的响应式系统相对于 Vue 2 更加现代化和高效，但在使用时需要注意一些 API 的变化和兼容性问题。

## diff算法是什么？原理是什么？

**Diff算法是一种对比算法**。对比两者是`旧虚拟DOM和新虚拟DOM`，对比出是哪个`虚拟节点`更改了，找出这个`虚拟节点`，并只更新这个虚拟节点所对应的`真实节点`，而不用更新其他数据没发生改变的节点，实现`精准`地更新真实DOM，进而`提高效率`。

新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:`深度优先算法`。 时间复杂度:`O(n)`

具体流程见 https://juejin.cn/post/6994959998283907102

vue2：深度递归+双指针

1. 判断是不是同一个元素 不是同一个元素的话直接替换
2. 是同一个元素的话 => 比对属性是否相同 => 然后比对子元素
   1. new没有子元素，old有子元素，直接把old的子元素去掉
   2. new有子元素，old没有子元素，直接把new的子元素追加
   3. 都是文本的情况 创建文本
   4. 都有子元素 双指针比对 头头相比，尾尾相比，尾头相比，对比后进行复用 

vue3：优化 采用的是**最长递增子序列**