# Usecallback 和useDemo的区别

useMemo 和 useCallback 接收的参数都是一样,第一个参数为回调 第二个参数为要依赖的数据

共同作用：仅仅 依赖数据 发生变化, 才会重新计算结果，也就是起到缓存的作用。

useCallback和useMemo都可缓存函数的引用或值，但是从更细的使用角度来说useCallback缓存函数的引用，useMemo缓存计算数据的值。

两者区别：

1.useMemo 计算结果是 return 回来的值, 主要用于 缓存计算结果的值 ，应用场景如： 需要计算的状态

2.useCallback 计算结果是 函数, 主要用于 缓存函数，应用场景如: 需要缓存的函数，因为函数式组件每次任何一个 state 的变化 整个组件 都会被重新刷新，一些函数是没有必要被重新刷新的，此时就应该缓存起来，提高性能，和减少资源浪费。

注意： 不要滥用会造成性能浪费，react中减少render就能提高性能，所以这个仅仅只针对缓存能减少重复渲染时使用和缓存计算结果。

他俩缓存的原理：**闭包**

# React Hooks为什么更容易复用

这点应该是`react hooks`最大的优点，它通过自定义hooks来复用状态，从而解决了类组件有些时候难以复用逻辑的问题。hooks是怎么解决这个复用的问题呢，具体如下：

1. 每调用useHook一次都会生成一份独立的状态，这个没有什么黑魔法，函数每次调用都会开辟一份独立的内存空间。
2. 虽然状态(from useState)和副作用(`useEffect`)的存在依赖于组件，但它们可以在组件外部进行定义。这点是`class component`做不到的，你无法在外部声明state和副作用（如`componentDidMount`）。

上面这两点，高阶组件和renderProps也同样能做到。但hooks实现起来的代码量更少，以及更直观（代码可读性）

# **为什么 hooks 不能写在循环或者条件判断语句里**

确保 Hooks 在每一次渲染中都按照同样的顺序被调用。我们可以把文件里所有的Hooks按照出现顺序当成一个链表，每次更新的时候这个链表都得保持一致，然而当条件存在时，当条件从真->假时，这个链表会变化。

# React与Vue的区别是什么？

React和Vue是两个流行的JavaScript库，用于构建用户界面。它们有很多相似之处，但也有一些显著的区别：

1. **设计理念**：
   - React是由Facebook开发的，专注于提供一个高效的、灵活的方式来构建用户界面。它提供了一个组件化的开发模型，允许开发人员构建复杂的UI，同时保持代码的可维护性。
   - Vue由尤雨溪开发，旨在提供一个简单易用的框架来构建可交互的界面。Vue注重易用性和灵活性，同时也提供了组件化的开发方式。
2. **语法和模板**：
   - React使用JSX（JavaScript XML）作为其主要的模板语言，允许在JavaScript中编写类似HTML的代码。
   - Vue使用模板语法，类似于HTML，但具有一些特殊的指令和语法糖，用于绑定数据、控制结构等。
3. **数据绑定**：
   - 在React中，数据流是单向的，通过props将数据从父组件传递到子组件。React使用状态管理库（如Redux）来处理应用的复杂状态。
   - Vue提供了双向数据绑定，允许开发人员直接在模板中修改数据，同时也提供了单向数据流的选项。
4. **生态系统**：
   - React拥有庞大的生态系统，包括许多第三方库和工具，如Redux、React Router、Material-UI等，可以帮助开发人员构建各种类型的应用。
   - Vue的生态系统虽然不如React庞大，但也在不断增长，并且有许多类似的库和工具可供选择，如Vuex、Vue Router、Vuetify等。
5. **学习曲线**：
   - 一般来说，Vue的学习曲线相对较低，因为它的API和模板语法都比较直观和易于理解。
   - React的学习曲线可能会更陡峭一些，特别是对于那些不熟悉JSX和单向数据流概念的开发者来说。

总的来说，React更注重灵活性和性能，适用于构建大型、高性能的应用程序；而Vue更注重简单易用和快速上手，适用于快速原型开发以及中小型项目。选择使用哪个库通常取决于项目的需求、团队的技能水平以及个人偏好。

# JSX是什么，它和JS有什么区别

JSX是react的语法糖，它允许在html中写JS，它不能被浏览器直接识别，需要通过webpack、babel之类的编译工具转换为JS执行

JSX与JS的区别：

1. JS可以被打包工具直接编译，不需要额外转换，jsx需要通过babel编译，它是React.createElement的语法糖，使用jsx等价于React.createElement
2. jsx是js的语法扩展，允许在html中写JS；JS是原生写法，需要通过script标签引入

# props 的变动，是否会引起 state hook 中数据的变动？

React 组件的 props 变动，会让组件重新执行，但并不会引起 state 的值的变动。state 值的变动，只能由 setState() 来触发。因此若想在 props 变动时，重置 state 的数据，需要监听 props 的变动，如：

```javascript
COPYJAVASCRIPTconst App = props => {
  const [count, setCount] = useState(0);

  // 监听 props 的变化，重置 count 的值
  useEffect(() => {
    setCount(0);
  }, [props]);

  return <div onClick={() => setCount(count + 1)}>{count}</div>;
};
```

# React 事件机制原理

React 的事件处理机制可以分为两个阶段：初始化渲染时在 root 节点上注册原生事件；原生事件触发时模拟捕获、目标和冒泡阶段派发合成事件。通过这种机制，冒泡的原生事件类型最多在 root 节点上注册一次，节省内存开销。且 React 为不同类型的事件定义了不同的处理优先级，从而让用户代码及时响应高优先级的用户交互，提升用户体验。

React 的事件机制中依赖合成事件这个核心概念。合成事件在符合 W3C 规范定义的前提下，抹平浏览器之间的差异化表现。并且简化事件逻辑，对关联事件进行合成。如每当表单类型组件的值发生改变时，都会触发 onChange 事件，而 onChange 事件由 change、click、input、keydown、keyup 等原生事件组成。