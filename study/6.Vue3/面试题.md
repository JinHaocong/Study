# vue3相比于vue2有哪些区别？

Vue.js 3相对于Vue.js 2有一些显著的区别和改进。以下是一些主要的区别：

1. **性能优化：** Vue 3在性能方面进行了许多优化。它引入了更快的虚拟DOM算法，称为Fragment API，以提高渲染性能。
2. **Composition API：** Vue 3引入了Composition API，这是一种新的组织组件逻辑的方式。它允许将组件的逻辑拆分为更小的功能性单元，使得代码更易读、可维护。
3. **Typescript支持：** Vue 3对TypeScript的支持更加友好。它是使用TypeScript编写的，因此在开发时可以获得更好的类型检查和自动补全。
4. **Teleport组件：** Vue 3引入了Teleport组件，允许您在DOM中的不同位置渲染组件的内容。这对于处理全局弹出框等情况非常有用。
5. **响应式系统改进：** Vue 3对响应式系统进行了改进，提供了更好的性能和更细粒度的控制。这包括reactive函数和ref函数等。
6. **更小的包大小：** Vue 3的包大小相对较小，这有助于减小应用程序的加载时间。
7. **全局API的变化：** 一些全局API的名称和用法在Vue 3中发生了变化，需要注意迁移指南中的更新。

这些只是一些主要的变化，还有其他一些较小的改进和新功能。在升级到Vue 3之前，建议查阅Vue.js官方文档中的迁移指南，以确保应用程序可以平稳过渡。

# OptionsAPI 与 CompositionAPI 有什么区别？

Vue.js 2.x 使用的是 Options API，而 Vue.js 3.x 引入了 Composition API。下面是两者之间的主要区别：

1. **组织代码的方式：**
   - **Options API：** 基于选项的 API，将组件的不同功能（data、methods、computed等）组织在不同的选项中。
   - **Composition API：** 基于函数的 API，通过函数的形式将组件的逻辑组织在一起。你可以使用 `setup` 函数来组织数据、计算属性、方法等。
2. **可复用性和逻辑组合：**
   - **Options API：** 在大型组件中，逻辑的复用和组合变得困难，因为不同功能的代码散布在不同的选项中。
   - **Composition API：** 提供了更好的可复用性和逻辑组合，通过将相关的逻辑放在一个函数中，可以更容易地组合和重用代码。
3. **逻辑封装：**
   - **Options API：** 逻辑通常分散在 `data`、`methods`、`computed` 等选项中，有时难以跟踪组件的整体逻辑。
   - **Composition API：** 通过 `setup` 函数，可以更清晰地封装组件的逻辑，使其更易于理解和维护。
4. **Typescript 支持：**
   - **Options API：** Typescript 支持较好，但在复杂组件中可能需要更多类型声明。
   - **Composition API：** 更灵活的类型推断和支持，特别适合在 Typescript 中编写组件。
5. **响应性：**
   - **Options API：** 使用 `data` 中的对象来实现响应性。
   - **Composition API：** 使用 `ref` 和 `reactive` 函数来实现响应性，提供了更直观的响应性 API。

总的来说，Composition API 提供了更灵活、可维护性更强、可复用性更好的方式来组织和管理组件的逻辑，特别是对于大型项目或需要更高抽象层次的场景。 Options API 仍然是Vue.js的一部分，并且在一些简单或小型项目中可能仍然是合适的选择。

# Vue3 的setup是什么？

在 Vue.js 3 中，`setup` 是 Composition API 的一部分，用于设置组件的逻辑和数据。`setup` 函数在组件创建阶段执行，它接收两个参数：`props` 和 `context`。

1. **`props` 参数：**
   - 用于接收组件的属性。在 `setup` 函数中，你可以直接访问传递给组件的 props。
2. **`context` 参数：**
   - 为了保持与 Options API 的一致性，`context` 参数提供了一个对象，包含了与组件实例相关的属性和方法，比如 `attrs`、`slots`、`emit` 等。

`setup` 函数返回一个对象，该对象中包含组件的响应式数据、计算属性、方法等。这个返回的对象将成为组件实例的上下文，你可以在模板中访问它的属性。

以下是一个简单的例子：

```vue
<script>
import { ref } from 'vue';

export default {
  props: {
    message: String
  },
  setup(props, context) {
    // 响应式数据
    const count = ref(0);

    // 计算属性
    const doubledCount = computed(() => count.value * 2);

    // 方法
    const increment = () => {
      count.value++;
      // 触发父组件的事件
      context.emit('increment');
    };

    return {
      count,
      doubledCount,
      increment
    };
  }
};
</script>
```

在这个例子中，`setup` 函数返回了一个包含响应式数据 `count`、计算属性 `doubledCount` 和方法 `increment` 的对象。这些数据和方法可以在组件的模板中直接使用，而不需要像 Options API 那样使用 `this`。

# setup与Options API的关系？

`setup` 函数是 Vue.js 3 中引入的 Composition API 的一部分，与 Options API 有一些重要的区别和关联。下面是它们之间的关系：

1. **Options API：**
   - Options API 是 Vue.js 2.x 中使用的默认 API。它将组件的不同功能（如数据、方法、生命周期钩子等）组织在不同的选项中，通过在组件对象中声明这些选项来定义组件。
2. **Composition API：**
   - Composition API 是 Vue.js 3 中引入的一种新的组织代码的方式。它允许你通过 `setup` 函数将组件的逻辑组织在一起，而不是散布在不同的选项中。这使得代码更加灵活、可维护性更强，并且更容易实现逻辑的复用和组合。
3. **关系：**
   - 在 Vue.js 3 中，你可以选择使用 Composition API 替代 Options API。`setup` 函数是 Composition API 的入口，它接受 `props` 和 `context` 作为参数，并返回一个对象，该对象包含组件的响应式数据、计算属性、方法等。这个返回的对象将成为组件实例的上下文。
4. **Options API 与 setup 的结合使用：**
   - 在 Vue.js 3 中，你可以选择将 Options API 与 Composition API 结合使用。你可以在组件中同时声明选项（如 `data`、`methods`）和使用 `setup` 函数。这种混合使用的方式在迁移逐步迁移到 Composition API 的过程中可能会有用。
5. **重名数据，方法以setup中为主**
6. **setup 比 data 执行的早**
7. **data 可以通过 this 读取 setup 中的数据，方法，反之不可以**

下面是一个简单的例子，展示了如何在 Vue.js 3 中同时使用 Options API 和 Composition API：

```vue
<template>
  <div class="person">
    <h2>姓名：{{name}}</h2>
    <h2>年龄：{{age}}</h2>
    <button @click="changeName">修改名字</button>
    <button @click="changeAge">修改年龄</button>
    <button @click="showTel">查看联系方式</button>
    <hr>
    <h2>测试1：{{a}}</h2>
    <h2>测试2：{{c}}</h2>
    <h2>测试3：{{d}}</h2>
    <button @click="b">测试</button>
  </div>
</template>

<script lang="ts">
  export default {
    name:'Person',
    beforeCreate(){
      console.log('beforeCreate')
    },
    data(){
      return {
        a:100,
        c:this.name,
        d:900,
        age:90
      }
    },
    methods:{
      b(){
        console.log('b')
      }
    },
    setup(){
      // 数据，原来是写在data中的，此时的name、age、tel都不是响应式的数据
      let name = '张三'
      let age = 18
      let tel = '13888888888'
      
      // 方法
      function changeName() {
        name = 'zhang-san' //注意：这样修改name，页面是没有变化的
        console.log(name) //name确实改了，但name不是响应式的
      }
      function changeAge() {
        age += 1 //注意：这样修改age，页面是没有变化的
        console.log(age) //age确实改了，但age不是响应式的
      }
      function showTel() {
        alert(tel)
      }

      // 将数据、方法交出去，模板中才可以使用
      return {name,age,tel,changeName,changeAge,showTel}

      // setup的返回值也可以是一个渲染函数
      // return ()=>'哈哈'
    }
  }
</script>

<style scoped>
  .person {
    background-color: skyblue;
    box-shadow: 0 0 10px;
    border-radius: 10px;
    padding: 20px;
  }
  button {
    margin: 0 5px;
  }
</style>
```

在这个例子中，`data` 选项用于声明响应式数据，而 `setup` 函数用于返回其他逻辑。这种方式允许逐步迁移到 Composition API。

# vue3 的 ref 和 reactive 有什么区别？

宏观角度看：

> 1. `ref`用来定义：**基本类型数据**、**对象类型数据**；
>
> 2. `reactive`用来定义：**对象类型数据**。

- 区别：

> 1. `ref`创建的变量必须使用`.value`（vscode 可以使用`volar`插件自动添加`.value`）。
>
>    <img src="E:/Study/study/6.Vue3/images/自动补充value.png" alt="自动补充value" style="zoom:50%;border-radius:20px" /> 
>
> 2. `reactive`重新分配一个新对象，会**失去**响应式（可以使用`Object.assign`去整体替换）。

- 使用原则：

> 1. 若需要一个基本类型的响应式数据，必须使用`ref`。
> 2. 若需要一个响应式对象，层级不深，`ref`、`reactive`都可以。
> 3. 若需要一个响应式对象，且层级较深，推荐使用`reactive`。

**ref表面上是创建了一个响应式对象，底层还是基于reactive的**

# `watch`对比`watchEffect`有什么区别？

`watch` 和 `watchEffect` 是 Vue 3 提供的两种不同的响应式数据监听方法，它们之间有一些关键区别：

1. **用法：**
   - **`watch`：** 用于监视特定的响应式数据或计算属性，并在它们变化时执行回调函数。你需要明确指定要监视的数据，可以是一个 ref、reactive 对象的属性、computed 属性等。
   - **`watchEffect`：** 用于监听一个函数内部使用的响应式数据，当该函数内部的响应式数据发生变化时，自动执行该函数。不需要明确指定要监视的数据，函数内使用到的响应式数据会自动形成依赖关系。
2. **依赖追踪：**
   - **`watch`：** 需要显式指定要监视的响应式数据，只有指定的数据发生变化时才会执行回调函数。
   - **`watchEffect`：** 自动追踪函数内部使用到的响应式数据，所有被使用的响应式数据都会成为依赖。只要任何一个依赖变化，就会执行函数。
3. **返回值：**
   - **`watch`：** 返回一个停止监听的函数，可以用于停止 watch 的效果。
   - **`watchEffect`：** 不返回停止监听的函数，而是在组件卸载时自动停止监听。
4. **使用场景：**
   - **`watch`：** 适用于需要精确控制监视的数据和执行回调函数的场景，比如监视特定的数据变化后执行一些异步操作。
   - **`watchEffect`：** 适用于希望自动追踪函数内部响应式数据变化，并执行一些与 UI 无关的逻辑，比如数据收集、日志记录等。

下面是一个简单的示例，演示了 `watch` 和 `watchEffect` 的使用：

```ts
<script lang="ts" name="Person" setup>
import { ref, watch, watchEffect } from 'vue'

// 数据
let temp = ref<number>(10)
let height = ref<number>(0)

// 方法
function changeTemp() {
  temp.value += 10
}

function changeHeight() {
  height.value += 10
}

// 监视 -- watch实现
watch([temp, height], ([newTemp, newHeight]: [number, number]) => {
  // 从value中获取最新的水温(newTemp)、最新的水位(newHeight)
  // 逻辑
  if (newTemp >= 60 || newHeight >= 80) {
    console.log('给服务器发请求')
  }
})

// 监视 -- watchEffect实现
watchEffect(() => {
  if (temp.value >= 60 || height.value >= 80) {
    console.log('给服务器发请求')
  }
})
</script>
```

`watch` 和 `watchEffect` 都能响应式地执行有副作用的回调。它们之间的主要区别是**追踪响应式依赖的方式**：

- `watch` 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。`watch` 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。
- `watchEffect`，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。