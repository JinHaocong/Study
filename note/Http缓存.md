在web中，http请求一般都是浏览器发起的，所以这里说的http缓存策略其实也就是浏览器端的缓存策略，http本身只是一种协议，真正想要实现缓存还得靠浏览器(浏览器指定存储硬盘下)

可能有的小伙伴就会直接想到，直接将http请求到的数据，存储到localstory中不就可以啦，是的，本质上最核心的就是这样，那为什么我们所遇到的浏览器缓存问题就那么复杂呢？

原因就在于要想实现一个完整的缓存，我们需要考虑很多实际因素，例如：

1. 我们设置完缓存以后，之后的数据总不能一直从缓存中读吧，因为我们请求的资源可能是会随时变化的，所以是不是需要给定一个策略，去告诉浏览器什么时候读缓存的数据，什么时候又重新请求服务器端的数据呢？答案当然是需要的，这也就是响应头返回的Expires，Cache-Control等字段的作用，即给一个缓存的失效时间不就可以啦。
2. 光给一个缓存的失效时间就可以了吗？例如我们发送了一个请求，服务器端告诉浏览器端缓存的失效时间是10s中，那我们在10s之后重新请求，如果这个请求返回的数据根本没有变化，其实我们是不是没必要重新请求呀，直接读缓存不就可以啦，所以呢？我们还需要判断服务器端的资源是否发生了变化，那如何判断呢？这就是Last-Modified和Etag的作用，前者是资源的最后修改时间，后者是资源的唯一标识，我们稍后会细讲。

相信通过上面的介绍，我们应该对如何实现缓存，有了一个大致的了解，知道了原来缓存需要考虑这么多因素，才可以最终覆盖到各种情况，从而能走缓存的时候，尽可能走缓存，不能走缓存的时候，也不能胡乱走缓存。

接下来，我们就来详细介绍一下浏览器的缓存策略。

# Http缓存策略

首先要知道；**Http的缓存策略，是由客户端和服务器端共同去控制的，客户端可以通过在请求头中添加Cache-Control等字段来决定是否走缓存，服务器端也可以在响应头中添加Cache-Control等字段来告诉客户端是否可以缓存数据**

## 服务器端的缓存控制

- Expires
- Cache-Control
- Last-Modified
- Etag

### 1，Expires

Expires表示服务端告诉客户端当前资源的失效时间，截止到那个时间点，是一个绝对时间，过了这个时间点再去请求，缓存失效，这个字段是Http1.0提出的，现在基本都用Cache-Control来替代

### 2，Cache-Control

- max-age；即Cache-Control:max-age:5000；表示缓存在5s后失效，是一个相对时间，改时间是从响应报文创建时间就开始计时。
- no-store；表示**不允许缓存**，通常一些频繁变化的页面这么设置
- no-cache；表示**允许缓存**，但是使用之前必须去服务端验证是否过期，没有过期使用缓存，过期则返回新数据
- must-revalidate；表示允许缓存，如果缓存不过期的话，使用缓存，如果缓存过期的话再去服务端验证。

服务器端控制缓存的流程；是否允许缓存(no-store) => 使用缓存前必须验证(no-cache) => 缓存失效后必须验证(must-revalidate) => 最多缓存多久(max-age=x)

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55faae0a0f9743cc8904a60c001be319~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

## 客户端的缓存控制

上面我们介绍了，服务器端如何在响应头中添加响应的字段来浏览来是否可以使用缓存，同样，客户端自己也可以控制，即浏览器也可以在请求中中添加Cache-Control等字段。

三种场景

1. 浏览器刷新

   即按F5刷新页面，该页面的Http请求会加；Cache-Control:max-age:0，即缓存直接失效，从服务端获取新数据。

2. 浏览器强制刷新

   即按ctrl+F5强制刷新页面，该页面的Http请求会加Cache-Control:no-cache；表示先去服务器验证是否有更新，如果有更新则返回最新资源，没有更新返回304，然后浏览器判断304后，从缓存中读取数据。

3. 浏览器前进后退重定向

​		点击浏览器前进后退操作时，这时候的请求中不会有Cache-Control字段，没有该字段就表示会检查缓存，直接利用之前的资源，不在重新请求服务器。

## 如何去服务端验证资源是否有变化(协商缓存)

上面其实我们已经介绍了客户端是如何判断是否可以进行缓存，以及缓存的失效时间了，即通过Cache-Control:max-age或者no-store来告诉浏览器是否可以对数据进行缓存，以及缓存的失效时间。

那服务器端如何判断呢？即通过Last-Modified/if-Modified-Since，或者ETag/If-None-Match来判断即可，

1. Last-Modified/if-Modified-Since

即该字段是服务器端返回给客户端的响应头字段，表示当前请求的资源的最后修改时间，如果响应头中有该字段，那么下次请求的时候，请求头中就会包含if-Modified-Since字段，它的值就是Last-Modified的值，这样服务器端收到该字段的值，就可以和对应的资源最终的修改时间做对比，如果发生变化，则说明资源发生了变化，则返回最新资源（此时状态码是200），如果没有发生变化，则返回304，浏览器从缓存中直接去数据即可。

1. ETag/If-None-Match

使用资源的最后更改时间作为判断资源是否更改可能会有问题？比如：资源改了之后，又改了回来，这时虽然资源的最后修改时间发生了变化，但其实资源内容本身没有发生变化，其实这种情况也应该是走缓存的，所以才出现了ETag字段，表示资源的唯一标识，那如果响应头中有该字段，则下次请求的时候，请求头中就会有If-None-Match字段，它的值就是ETag的值，服务器端收到以后，就会和当前资源的唯一表识别去对比，如果不一样，则说明资源发生变化，返回最新数据即可（此时状态码是200），如果一样，则说明资源没有变化，返回304，浏览器从缓存中读取数据。

## 总结

1. 首先浏览器会根据Cache-Control是否是no-sore来判断是否对返回的数据进行缓存。
2. 如果不是no-store，一般就是返回max-age:5000；来告诉浏览器可以缓存数据，并通过max-age设置过期时间，max-age会搭配no-cache，must-revalidate一起返回