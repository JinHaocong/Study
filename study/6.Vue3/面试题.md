# vue3相比于vue2有哪些区别？

Vue.js 3相对于Vue.js 2有一些显著的区别和改进。以下是一些主要的区别：

1. **性能优化：** Vue 3在性能方面进行了许多优化。它引入了更快的虚拟DOM算法，称为Fragment API，以提高渲染性能。
2. **Composition API：** Vue 3引入了Composition API，这是一种新的组织组件逻辑的方式。它允许将组件的逻辑拆分为更小的功能性单元，使得代码更易读、可维护。
3. **Typescript支持：** Vue 3对TypeScript的支持更加友好。它是使用TypeScript编写的，因此在开发时可以获得更好的类型检查和自动补全。
4. **Teleport组件：** Vue 3引入了Teleport组件，允许您在DOM中的不同位置渲染组件的内容。这对于处理全局弹出框等情况非常有用。
5. **响应式系统改进：** Vue 3对响应式系统进行了改进，提供了更好的性能和更细粒度的控制。这包括reactive函数和ref函数等。
6. **更小的包大小：** Vue 3的包大小相对较小，这有助于减小应用程序的加载时间。
7. **全局API的变化：** 一些全局API的名称和用法在Vue 3中发生了变化，需要注意迁移指南中的更新。

这些只是一些主要的变化，还有其他一些较小的改进和新功能。在升级到Vue 3之前，建议查阅Vue.js官方文档中的迁移指南，以确保应用程序可以平稳过渡。

# OptionsAPI 与 CompositionAPI 有什么区别？

Vue.js 2.x 使用的是 Options API，而 Vue.js 3.x 引入了 Composition API。下面是两者之间的主要区别：

1. **组织代码的方式：**
   - **Options API：** 基于选项的 API，将组件的不同功能（data、methods、computed等）组织在不同的选项中。
   - **Composition API：** 基于函数的 API，通过函数的形式将组件的逻辑组织在一起。你可以使用 `setup` 函数来组织数据、计算属性、方法等。
2. **可复用性和逻辑组合：**
   - **Options API：** 在大型组件中，逻辑的复用和组合变得困难，因为不同功能的代码散布在不同的选项中。
   - **Composition API：** 提供了更好的可复用性和逻辑组合，通过将相关的逻辑放在一个函数中，可以更容易地组合和重用代码。
3. **逻辑封装：**
   - **Options API：** 逻辑通常分散在 `data`、`methods`、`computed` 等选项中，有时难以跟踪组件的整体逻辑。
   - **Composition API：** 通过 `setup` 函数，可以更清晰地封装组件的逻辑，使其更易于理解和维护。
4. **Typescript 支持：**
   - **Options API：** Typescript 支持较好，但在复杂组件中可能需要更多类型声明。
   - **Composition API：** 更灵活的类型推断和支持，特别适合在 Typescript 中编写组件。
5. **响应性：**
   - **Options API：** 使用 `data` 中的对象来实现响应性。
   - **Composition API：** 使用 `ref` 和 `reactive` 函数来实现响应性，提供了更直观的响应性 API。

总的来说，Composition API 提供了更灵活、可维护性更强、可复用性更好的方式来组织和管理组件的逻辑，特别是对于大型项目或需要更高抽象层次的场景。 Options API 仍然是Vue.js的一部分，并且在一些简单或小型项目中可能仍然是合适的选择。

# Vue3 的setup是什么？

在 Vue.js 3 中，`setup` 是 Composition API 的一部分，用于设置组件的逻辑和数据。`setup` 函数在组件创建阶段执行，它接收两个参数：`props` 和 `context`。

1. **`props` 参数：**
   - 用于接收组件的属性。在 `setup` 函数中，你可以直接访问传递给组件的 props。
2. **`context` 参数：**
   - 为了保持与 Options API 的一致性，`context` 参数提供了一个对象，包含了与组件实例相关的属性和方法，比如 `attrs`、`slots`、`emit` 等。

`setup` 函数返回一个对象，该对象中包含组件的响应式数据、计算属性、方法等。这个返回的对象将成为组件实例的上下文，你可以在模板中访问它的属性。

以下是一个简单的例子：

```vue
<script>
import { ref } from 'vue';

export default {
  props: {
    message: String
  },
  setup(props, context) {
    // 响应式数据
    const count = ref(0);

    // 计算属性
    const doubledCount = computed(() => count.value * 2);

    // 方法
    const increment = () => {
      count.value++;
      // 触发父组件的事件
      context.emit('increment');
    };

    return {
      count,
      doubledCount,
      increment
    };
  }
};
</script>
```

在这个例子中，`setup` 函数返回了一个包含响应式数据 `count`、计算属性 `doubledCount` 和方法 `increment` 的对象。这些数据和方法可以在组件的模板中直接使用，而不需要像 Options API 那样使用 `this`。

# setup与Options API的关系？

`setup` 函数是 Vue.js 3 中引入的 Composition API 的一部分，与 Options API 有一些重要的区别和关联。下面是它们之间的关系：

1. **Options API：**
   - Options API 是 Vue.js 2.x 中使用的默认 API。它将组件的不同功能（如数据、方法、生命周期钩子等）组织在不同的选项中，通过在组件对象中声明这些选项来定义组件。
2. **Composition API：**
   - Composition API 是 Vue.js 3 中引入的一种新的组织代码的方式。它允许你通过 `setup` 函数将组件的逻辑组织在一起，而不是散布在不同的选项中。这使得代码更加灵活、可维护性更强，并且更容易实现逻辑的复用和组合。
3. **关系：**
   - 在 Vue.js 3 中，你可以选择使用 Composition API 替代 Options API。`setup` 函数是 Composition API 的入口，它接受 `props` 和 `context` 作为参数，并返回一个对象，该对象包含组件的响应式数据、计算属性、方法等。这个返回的对象将成为组件实例的上下文。
4. **Options API 与 setup 的结合使用：**
   - 在 Vue.js 3 中，你可以选择将 Options API 与 Composition API 结合使用。你可以在组件中同时声明选项（如 `data`、`methods`）和使用 `setup` 函数。这种混合使用的方式在迁移逐步迁移到 Composition API 的过程中可能会有用。
5. **重名数据，方法以setup中为主**
6. **setup 比 data 执行的早**
7. **data 可以通过 this 读取 setup 中的数据，方法，反之不可以**

下面是一个简单的例子，展示了如何在 Vue.js 3 中同时使用 Options API 和 Composition API：

```vue
<template>
  <div class="person">
    <h2>姓名：{{name}}</h2>
    <h2>年龄：{{age}}</h2>
    <button @click="changeName">修改名字</button>
    <button @click="changeAge">修改年龄</button>
    <button @click="showTel">查看联系方式</button>
    <hr>
    <h2>测试1：{{a}}</h2>
    <h2>测试2：{{c}}</h2>
    <h2>测试3：{{d}}</h2>
    <button @click="b">测试</button>
  </div>
</template>

<script lang="ts">
  export default {
    name:'Person',
    beforeCreate(){
      console.log('beforeCreate')
    },
    data(){
      return {
        a:100,
        c:this.name,
        d:900,
        age:90
      }
    },
    methods:{
      b(){
        console.log('b')
      }
    },
    setup(){
      // 数据，原来是写在data中的，此时的name、age、tel都不是响应式的数据
      let name = '张三'
      let age = 18
      let tel = '13888888888'
      
      // 方法
      function changeName() {
        name = 'zhang-san' //注意：这样修改name，页面是没有变化的
        console.log(name) //name确实改了，但name不是响应式的
      }
      function changeAge() {
        age += 1 //注意：这样修改age，页面是没有变化的
        console.log(age) //age确实改了，但age不是响应式的
      }
      function showTel() {
        alert(tel)
      }

      // 将数据、方法交出去，模板中才可以使用
      return {name,age,tel,changeName,changeAge,showTel}

      // setup的返回值也可以是一个渲染函数
      // return ()=>'哈哈'
    }
  }
</script>

<style scoped>
  .person {
    background-color: skyblue;
    box-shadow: 0 0 10px;
    border-radius: 10px;
    padding: 20px;
  }
  button {
    margin: 0 5px;
  }
</style>
```

在这个例子中，`data` 选项用于声明响应式数据，而 `setup` 函数用于返回其他逻辑。这种方式允许逐步迁移到 Composition API。

# vue3 的 ref 和 reactive 有什么区别？

宏观角度看：

> 1. `ref`用来定义：**基本类型数据**、**对象类型数据**；
>
> 2. `reactive`用来定义：**对象类型数据**。

- 区别：

> 1. `ref`创建的变量必须使用`.value`（vscode 可以使用`volar`插件自动添加`.value`）。
>
>    <img src="E:/Study/study/6.Vue3/images/自动补充value.png" alt="自动补充value" style="zoom:50%;border-radius:20px" /> 
>
> 2. `reactive`重新分配一个新对象，会**失去**响应式（可以使用`Object.assign`去整体替换）。

- 使用原则：

> 1. 若需要一个基本类型的响应式数据，必须使用`ref`。
> 2. 若需要一个响应式对象，层级不深，`ref`、`reactive`都可以。
> 3. 若需要一个响应式对象，且层级较深，推荐使用`reactive`。

**ref表面上是创建了一个响应式对象，底层还是基于reactive的**

# `watch`对比`watchEffect`有什么区别？

`watch` 和 `watchEffect` 是 Vue 3 提供的两种不同的响应式数据监听方法，它们之间有一些关键区别：

1. **用法：**
   - **`watch`：** 用于监视特定的响应式数据或计算属性，并在它们变化时执行回调函数。你需要明确指定要监视的数据，可以是一个 ref、reactive 对象的属性、computed 属性等。
   - **`watchEffect`：** 用于监听一个函数内部使用的响应式数据，当该函数内部的响应式数据发生变化时，自动执行该函数。不需要明确指定要监视的数据，函数内使用到的响应式数据会自动形成依赖关系。
2. **依赖追踪：**
   - **`watch`：** 需要显式指定要监视的响应式数据，只有指定的数据发生变化时才会执行回调函数。
   - **`watchEffect`：** 自动追踪函数内部使用到的响应式数据，所有被使用的响应式数据都会成为依赖。只要任何一个依赖变化，就会执行函数。
3. **返回值：**
   - **`watch`：** 返回一个停止监听的函数，可以用于停止 watch 的效果。
   - **`watchEffect`：** 不返回停止监听的函数，而是在组件卸载时自动停止监听。
4. **使用场景：**
   - **`watch`：** 适用于需要精确控制监视的数据和执行回调函数的场景，比如监视特定的数据变化后执行一些异步操作。
   - **`watchEffect`：** 适用于希望自动追踪函数内部响应式数据变化，并执行一些与 UI 无关的逻辑，比如数据收集、日志记录等。

下面是一个简单的示例，演示了 `watch` 和 `watchEffect` 的使用：

```ts
<script lang="ts" name="Person" setup>
import { ref, watch, watchEffect } from 'vue'

// 数据
let temp = ref<number>(10)
let height = ref<number>(0)

// 方法
function changeTemp() {
  temp.value += 10
}

function changeHeight() {
  height.value += 10
}

// 监视 -- watch实现
watch([temp, height], ([newTemp, newHeight]: [number, number]) => {
  // 从value中获取最新的水温(newTemp)、最新的水位(newHeight)
  // 逻辑
  if (newTemp >= 60 || newHeight >= 80) {
    console.log('给服务器发请求')
  }
})

// 监视 -- watchEffect实现
watchEffect(() => {
  if (temp.value >= 60 || height.value >= 80) {
    console.log('给服务器发请求')
  }
})
</script>
```

`watch` 和 `watchEffect` 都能响应式地执行有副作用的回调。它们之间的主要区别是**追踪响应式依赖的方式**：

- `watch` 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。`watch` 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。
- `watchEffect`，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。

# withDefaults 和 defineProps 都有什么作用？区别是什么？

`withDefaults` 和 `defineProps` 是 Vue 3 Composition API 中用于处理组件属性的两个不同函数。

### `defineProps`:

- **作用：** 用于在组件中定义接收的属性。

- **用法：** 在组件的 `setup` 函数中使用 `defineProps` 来声明组件接收的属性。这样做有助于类型检查，并且使属性在组件中的使用更加明确。

- 示例：

  ```ts
  import { defineProps } from 'vue';
  
  export default {
    props: ['name'],
    setup(props) {
      // 使用 defineProps 声明属性
      const { name } = defineProps(['name']);
  
      // 使用属性
      console.log(name);
  
      return {};
    },
  };
  ```

### `withDefaults`:

- **作用：** 用于在 `defineProps` 的基础上，提供默认值。

- **用法：** `withDefaults` 接受两个参数，第一个是 `defineProps` 的返回值，第二个是包含默认值的对象。它返回一个包含属性及其默认值的对象，这样你可以确保属性总是有一个值，即使它没有在父组件中传递。

- 示例：

  ```ts
  import { defineProps, withDefaults } from 'vue';
  
  export default {
    props: {
      name: String,
      age: {
        type: Number,
        default: 25,
      },
    },
    setup(props) {
      // 使用 defineProps 声明属性
      const { name, age } = defineProps(['name', 'age']);
  
      // 使用 withDefaults 提供默认值
      const propsWithDefaults = withDefaults(props, {
        age: 25,
      });
  
      // 使用属性及默认值
      console.log(name, age);
  
      return {};
    },
  };
  ```

### 区别：

- `defineProps` 主要用于声明接收的属性，并且可以进行类型检查。
- `withDefaults` 主要用于提供属性的默认值，它在 `defineProps` 的基础上添加了默认值的处理。

通常情况下，你会在 `setup` 函数中使用 `defineProps` 来声明接收的属性，并使用 `withDefaults` 来提供默认值。这两个函数结合使用可以方便地处理组件的属性。

# vue2 与 vue3 的生命周期分别是什么？

* 概念：`Vue`组件实例在创建时要经历一系列的初始化步骤，在此过程中`Vue`会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为：生命周期钩子

* 规律：

  > 生命周期整体分为四个阶段，分别是：**创建、挂载、更新、销毁**，每个阶段都有两个钩子，一前一后。

* `Vue2`的生命周期

  > 创建阶段：`beforeCreate`、`created`
  >
  > 挂载阶段：`beforeMount`、`mounted`
  >
  > 更新阶段：`beforeUpdate`、`updated`
  >
  > 销毁阶段：`beforeDestroy`、`destroyed`

* `Vue3`的生命周期

  > 创建阶段：`setup`
  >
  > 挂载阶段：`onBeforeMount`、`onMounted`
  >
  > 更新阶段：`onBeforeUpdate`、`onUpdated`
  >
  > 卸载阶段：`onBeforeUnmount`、`onUnmounted`

* 常用的钩子：`onMounted`(挂载完毕)、`onUpdated`(更新完毕)、`onBeforeUnmount`(卸载之前)

* 父子组件生命周期的关系：父-创建 => 父-挂载前 => 子-创建 => 子-挂载前 => 子-挂载完毕 => 父-挂载完毕

# vue3的自定义hook是什么？

在Vue.js 3中，自定义 Hook 是一种组织和重用逻辑的方式。自定义 Hook 实际上就是一个函数，以 "`use`" 开头命名，用于封装一些可复用的逻辑代码，可以在组件中使用。这样可以更好地组织代码，提高代码的可维护性和可复用性。

自定义 Hook 可以包含任何 Vue.js 特性，例如响应式数据、生命周期钩子等。通过使用自定义 Hook，可以将一些通用的逻辑抽离出来，使得多个组件可以共享同一段逻辑代码，避免代码重复。

例如，一个简单的自定义 Hook 可能如下所示：

```js
import { ref, onMounted } from 'vue';

function useCounter(initialValue) {
  const count = ref(initialValue);

  const increment = () => {
    count.value++;
  };

  const reset = () => {
    count.value = initialValue;
  };

  // 在组件被挂载时执行的生命周期钩子
  onMounted(() => {
    console.log('Counter component has been mounted');
  });

  // 返回需要在组件中使用的数据和方法
  return {
    count,
    increment,
    reset
  };
}

export default useCounter;
```

然后，你可以在组件中使用这个自定义 Hook：

```vue
<script>
import { defineComponent } from 'vue';
import useCounter from './useCounter';

export default defineComponent({
  setup() {
    const { count, increment, reset } = useCounter(0);

    return {
      count,
      increment,
      reset
    };
  }
});
</script>
```

这样，`useCounter` 就提供了一个可重用的计数器逻辑，可以在多个组件中使用。

# 路由器工作模式？

1. `history`模式

   > 优点：`URL`更加美观，不带有`#`，更接近传统的网站`URL`。
   >
   > 缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会有`404`错误。
   >
   > ```js
   > const router = createRouter({
   > 	history:createWebHistory(), //history模式
   > 	/******/
   > })
   > ```

2. `hash`模式

   > 优点：兼容性更好，因为不需要服务器端处理路径。
   >
   > 缺点：`URL`带有`#`不太美观，且在`SEO`优化方面相对较差。
   >
   > ```js
   > const router = createRouter({
   > 	history:createWebHashHistory(), //hash模式
   > 	/******/
   > })
   > ```

# vue3数据响应式是社么原理？与vue2有什么区别？


Vue 3 的数据响应式系统与 Vue 2 有一些重要的区别。Vue 3 的数据响应式系统基于 Proxy 对象，而 Vue 2 使用的是 Object.defineProperty。以下是一些主要的区别：

1. **Proxy vs. Object.defineProperty:**
   - Vue 3 使用 Proxy 对象来实现数据的响应式，这使得它能够捕捉更多的操作，包括数组的变化。
   - Vue 2 使用 Object.defineProperty 来劫持对象属性的 getter 和 setter，但它无法监听数组的变化，需要通过特殊的数组方法来实现。
2. **性能优化:**
   - 由于 Proxy 的设计，Vue 3 在性能上有一些优势。Proxy 可以直接监听整个对象的变化，而不需要遍历对象的每个属性。
   - Vue 2 的 Object.defineProperty 需要为每个属性单独设置 getter 和 setter，可能会导致性能瓶颈，特别是在处理大型对象时。
3. **Ref 和 Reactive:**
   - 在 Vue 3 中引入了 `ref` 和 `reactive` 函数，用于创建响应式对象。`ref` 主要用于包装基本类型，而 `reactive` 用于包装普通对象。
   - 在 Vue 2 中，使用 `new Vue()` 创建的实例对象本身就是响应式的。
4. **Composition API:**
   - Vue 3 引入了 Composition API，提供了更灵活和组织性更好的代码组织方式。这不仅仅是响应式系统的改变，而是一个更全面的 API 改进。
   - Vue 2 使用的是 Options API，相比之下，Composition API 允许更好地组织代码逻辑，特别是在处理复杂组件时。

总体而言，Vue 3 的数据响应式系统通过引入 Proxy 对象以及其他改进，提供了更好的性能和更灵活的开发体验。

# vue3 中的attrs是什么作用？

在Vue 3中，`attrs` 是一个用于接收父组件传递的非prop特性的对象。当一个子组件接收到来自父组件的属性，但这些属性在子组件中没有声明为props时，这些属性会被放入`attrs`对象中。

例如，考虑以下的父组件和子组件：

```vue
<!-- 父组件 ParentCom.vue -->
<template>
  <ChildCom
    msg="雷猴"
    data="123"
  />
</template>

<script setup>
import ChildCom from './ChildCom.vue'
</script>



<!-- 子组件 ChildCom.vue -->
<template>
  <div>
    {{ msg }} - {{ $attrs }}
  </div>
</template>

<script setup>
defineProps({
  msg: {
    type: String
  }
})
</script>
```

在上面的例子中，`title` 是通过props传递给子组件的，而 `customAttribute` 则不是通过props传递的，它会被放入`attrs`对象中。在子组件中通过`v-for`循环遍历`attrs`对象，你可以获取到所有父组件传递的非prop特性。

需要注意的是，如果你不设置 `inheritAttrs: false`，Vue 默认会将所有没有在子组件中声明的属性放入`attrs`中，但一旦你设置了 `inheritAttrs: false`，Vue 就只会将没有对应prop的属性放入`attrs`中。

# vue3中 默认插槽，具名插槽，作用域插槽是什么？有什么区别？

在Vue 3中，插槽是一种机制，允许你在父组件中将内容传递到子组件中，以便子组件可以渲染这些内容。Vue 3中有三种类型的插槽：默认插槽、具名插槽和作用域插槽。

1. **默认插槽（Default Slots）**:

   - 默认插槽是最基本的插槽类型，用于传递未命名的内容。
   - 在子组件中，你可以使用 `<slot>` 元素来表示默认插槽的位置。
   - 父组件中传递给子组件的内容会被放置在 `<slot>` 所在的位置。

   ```vue
   <!-- ParentComponent.vue -->
   <template>
     <ChildComponent>这是默认插槽的内容</ChildComponent>
   </template>
   ```

   ```vue
   <!-- ChildComponent.vue -->
   <template>
     <div>
       <p>子组件内容</p>
       <slot></slot> <!-- 这里是默认插槽的位置 -->
     </div>
   </template>
   ```

2. **具名插槽（Named Slots）**:

   - 具名插槽允许你在父组件中传递内容到特定的插槽位置。
   - 在子组件中，你可以使用 `<slot>` 元素的 `name` 属性来表示具名插槽的位置。
   - 父组件中通过使用 `<template>` 的 `v-slot` 指令来指定插槽的名称。

   ```vue
   <!-- ParentComponent.vue -->
   <template>
     <ChildComponent>
       <template v-slot:header>这是头部插槽的内容</template>
       <template v-slot:footer>这是底部插槽的内容</template>
     </ChildComponent>
   </template>
   ```

   ```vue
   <!-- ChildComponent.vue -->
   <template>
     <div>
       <p>子组件内容</p>
       <slot name="header"></slot> <!-- 头部插槽位置 -->
       <slot name="footer"></slot> <!-- 底部插槽位置 -->
     </div>
   </template>
   ```

3. **作用域插槽（Scoped Slots）**:

   - 作用域插槽允许子组件在插槽中使用父组件的数据。
   - 在子组件中，你可以使用 `<slot>` 元素的 `v-slot` 指令，并通过参数将数据传递给插槽。
   - 父组件中通过使用 `<template>` 的 `v-slot` 指令来指定插槽，并获取子组件传递的数据。

   ```vue
   <!-- ParentComponent.vue -->
   <template>
     <ChildComponent>
       <template v-slot:default="slotProps">
         {{ slotProps.message }}
       </template>
     </ChildComponent>
   </template>
   ```

   ```vue
   <!-- ChildComponent.vue -->
   <template>
     <div>
       <p>子组件内容</p>
       <slot :message="data.message"></slot> <!-- 作用域插槽位置 -->
     </div>
   </template>
   
   <script>
   export default {
     data() {
       return {
         message: '这是来自子组件的消息',
       };
     },
   };
   </script>
   ```

总体而言，这三种插槽类型提供了不同的灵活性，使得在父子组件之间传递内容更加方便。默认插槽用于传递未命名的内容，具名插槽用于传递到特定插槽位置的内容，而作用域插槽则允许子组件在插槽中使用父组件的数据。

# vue3中的customRef是什么？

在Vue 3中，`customRef` 是一个用于创建自定义的 ref 的函数。`ref` 是 Vue 3 中用于在响应式数据中包装普通 JavaScript 对象的工具函数，使其能够被 Vue 的响应式系统追踪变化。

`customRef` 允许你创建一个具有自定义 getter 和 setter 的 ref。这对于一些高级用例或需要定制 getter 和 setter 行为的情况很有用。

以下是 `customRef` 的基本用法：

```ts
import { customRef } from 'vue';

const myCustomRef = customRef((track, trigger) => {
  return {
    get() {
      // 在依赖项被追踪时调用
      track();
      // 返回值
      return someValue;
    },
    set(value) {
      // 在 ref 被修改时调用
      // 执行一些逻辑
      // ...
      // 触发更新
      trigger();
    }
  };
});

// 使用
const myRef = myCustomRef();
```

`customRef` 接受一个工厂函数，该函数接收两个参数：`track` 和 `trigger`。`track` 用于通知 Vue 追踪依赖，`trigger` 用于触发更新。在工厂函数中，你需要返回一个包含 `get` 和 `set` 方法的对象，这些方法定义了 ref 的 getter 和 setter。

这使你能够完全控制 ref 的行为，例如在设置值时执行特定的逻辑，或在获取值时进行

# Teleport 是什么？

将其插槽内容渲染到 DOM 中的另一个位置。

- **Props**

  ```ts
  interface TeleportProps {
    /**
     * 必填项。指定目标容器。
     * 可以是选择器或实际元素。
     */
    to: string | HTMLElement
    /**
     * 当值为 `true` 时，内容将保留在其原始位置
     * 而不是移动到目标容器中。
     * 可以动态更改。
     */
    disabled?: boolean
  }
  ```

- **示例**

  指定目标容器：

  ```vue
  <Teleport to="#some-id" />
  <Teleport to=".some-class" />
  <Teleport to="[data-teleport]" />
  ```

  有条件地禁用：

  ```vue
  <Teleport to="#popup" :disabled="displayVideoInline">
    <video src="./my-movie.mp4">
  </Teleport>
  ```