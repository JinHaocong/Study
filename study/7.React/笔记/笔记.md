# 项目创建

## webpack

```powershell
npx create-react-app my-app
```

```powershell
 yarn create react-app my-app
```

## vite

```powershell
yarn create vite
```

```powershell
 Project name: ... create-vite-react
√ Select a framework: » React
√ Select a variant: » TypeScript + SWC

Scaffolding project in E:\Study\study\7.React\React 基础 - day01\03-code\create-vite-react...

Done. Now run:

  cd create-vite-react
  yarn
  yarn dev

Done in 28.38s.

```

# useState

# useRef

# useEffect

`useEffect` 是 React 中的一个 Hook，用于处理副作用操作。副作用是指那些不直接与组件渲染相关的操作，比如数据获取、订阅、手动操作DOM等。`useEffect` 的主要目的是在组件渲染后执行这些副作用操作，以确保它们不会阻塞渲染。

`useEffect` 接受两个参数：

1. 第一个参数是一个函数，该函数包含要执行的副作用代码。
2. 第二个参数是一个数组，表示依赖项。当依赖项发生变化时，`useEffect` 就会重新执行。

```tsx
import React, { useEffect } from 'react';

function ExampleComponent() {
  // 使用 useEffect 处理副作用
  useEffect(() => {
    // 这里是副作用的代码
    console.log('Component has mounted');

    // 在组件卸载时执行清理操作
    return () => {
      console.log('Component will unmount');
    };
  }, []); // 传递一个空数组表示没有依赖项，只在组件挂载和卸载时执行

  return <div>This is a functional component</div>;
}
```

在这个例子中，`useEffect` 的第一个参数是一个包含副作用代码的函数。它将在组件挂载后执行一次，因为我们传递了一个空数组作为第二个参数。如果有依赖项，并且这些依赖项发生变化，`useEffect` 将在每次渲染后执行。在这个例子中，`useEffect` 中的清理函数将在组件卸载时执行。

`useEffect` 是处理异步代码、订阅、定时器、数据获取等常见场景的重要工具。通过使用 `useEffect`，可以确保在适当的时机执行副作用代码，避免了直接在 `render` 中执行可能导致性能问题的操作。

# createContext useContext

# 自定义hooks


在React中，自定义Hook是一种用于封装可复用逻辑的机制。它允许你将组件之间共享的状态逻辑提取到可重用的函数中，从而使代码更易于维护和组织。

自定义Hook的命名一般以"use"开头，以表明它是一个Hook。自定义Hook可以使用React的基本Hooks（如useState、useEffect等）以及其他自定义Hook，以创建具有复杂逻辑的组件。

以下是一个简单的例子，演示了一个自定义Hook的使用：

```tsx
import { useState, useEffect } from 'react';

// 自定义Hook，用于获取窗口的宽度和高度
function useWindowDimensions() {
  const [windowDimensions, setWindowDimensions] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    // 监听窗口变化
    const handleResize = () => {
      setWindowDimensions({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    // 添加事件监听器
    window.addEventListener('resize', handleResize);

    // 在组件卸载时清除事件监听器
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []); // 传递一个空数组表示仅在组件挂载和卸载时执行

  // 返回窗口尺寸
  return windowDimensions;
}

// 使用自定义Hook的组件
function MyComponent() {
  const { width, height } = useWindowDimensions();

  return (
    <div>
      Window Width: {width}, Window Height: {height}
    </div>
  );
}
```

在这个例子中，`useWindowDimensions` 是一个自定义Hook，它封装了获取窗口宽度和高度的逻辑。`MyComponent` 组件使用这个Hook来获取窗口尺寸并显示在页面上。这样，窗口尺寸的逻辑被抽象到一个独立的函数中，可以在任何需要获取窗口尺寸的组件中重复使用。

# 组件通信

## 父传子props

在React中，"props"（属性）是一种机制，用于从父组件向子组件传递数据。父组件可以通过props将数据传递给子组件，从而影响或配置子组件的行为和渲染。

具体来说，父组件可以在子组件标签上的属性中设置数据，子组件通过props对象接收这些属性。以下是一个简单的示例：

```tsx
// 父传子
// 1. 父组件传递数据  子组件标签身上绑定属性
// 2. 子组件接收数据  props的参数

// 子组件 Son
import {type ReactNode} from "react";

interface SonProps {
    name: string;
    age: number;
    isTrue: boolean;
    list: string[];
    obj: { name: string };
    cb: () => void;
    child: ReactNode;
}

function Son(props: SonProps) {
    // props：对象里面包含了父组件传递过来的所有的数据
    // { name:'父组件中的数据'}
    console.dir(props)
    return <div>this is son, {props.name}, jsx: {props.child}</div>
}


function App() {
    const name = 'this is App name'
    return (
        <div>
            <Son
                name={name}
                age={18}
                isTrue={false}
                list={['vue', 'react']}
                obj={{name: 'jack'}}
                cb={() => console.log(123)}
                child={<span>this is span</span>}
            />
        </div>
    )
}

export default App
```

这是React中使用props实现父传子数据的基本模式。props不仅可以传递基本的数据类型，还可以传递函数、对象等。 Props的传递是单向的，即从父组件流向子组件，而不能直接在子组件中修改props。

## 子传父自定义事件

```tsx
// 核心：在子组件中调用父组件中的函数并传递实参

import {useState} from "react"

interface SonProps {
    onGetSonMsg: (msg: string) => void
}


function Son(props: SonProps) {
    const {onGetSonMsg} = props
    // Son组件中的数据
    const sonMsg = 'this is son msg'
    return (
        <div>
            this is Son
            <button onClick={() => onGetSonMsg(sonMsg)}>sendMsg</button>
        </div>
    )
}

function App() {
    const [msg, setMsg] = useState('')
    const getMsg = (msg: string) => {
        console.log(msg)
        setMsg(msg)
    }
    return (
        <div>
            this is App, {msg}
            <Son onGetSonMsg={getMsg}/>
        </div>
    )
}

export default App

```

## 状态提升兄弟组件通信

```tsx
// 1. 通过子传父 A -> App
// 2. 通过父传子 App -> B

import {useState} from "react"

interface AProps {
    onGetAName: (name: string) => void
}

interface BProps {
    name: string
}


function A(props: AProps) {
    const {onGetAName} = props
    // Son组件中的数据
    const name = 'this is A name'
    return (
        <div>
            this is A component,
            <button onClick={() => onGetAName(name)}>send</button>
        </div>
    )
}

function B(props: BProps) {
    const {name} = props
    return (
        <div>
            this is B component,
            {name}
        </div>
    )
}

function App() {
    const [name, setName] = useState('')
    const getAName = (name: string) => {
        console.log(name)
        setName(name)
    }
    return (
        <div>
            this is App
            <A onGetAName={getAName}/>
            <B name={name}/>
        </div>
    )
}

export default App

```

## context跨层通信

```tsx
// App -> A -> B

import {createContext, useContext} from "react"

// 1. createContext方法创建一个上下文对象

const MsgContext = createContext('')

// 2. 在顶层组件 通过Provider组件提供数据

// 3. 在底层组件 通过useContext钩子函数使用数据

function A() {
    return (
        <div>
            this is A component
            <B/>
        </div>
    )
}

function B() {
    const msg = useContext(MsgContext)
    return (
        <div>
            this is B component,{msg}
        </div>
    )
}

function App() {
    const msg = 'this is app msg'
    return (
        <div>
            <MsgContext.Provider value={msg}>
                this is App
                <A/>
            </MsgContext.Provider>
        </div>
    )
}

export default App

```

# Redux

## 创建项目

```powershell
yarn create vite
success Installed "create-vite@5.2.1" with binaries:
      - create-vite
      - cva
√ Project name: ... react-redux-pro-vite
? Select a framework: » - Use arrow-keys. Return to submit.
>   Vanilla
    Vue
√ Select a framework: » React
√ Select a variant: » TypeScript + SWC

Scaffolding project in E:\Study\study\7.React\React 基础 - day03\03-code\react-redux-pro-vite...

Done. Now run:

  cd react-redux-pro-vite
  yarn
  yarn dev

Done in 245.47s.

```

## 安装Redux所需依赖

```powershell
yarn add @reduxjs/toolkit react-redux
```

## 创建子store使用@reduxjs/toolkit

React 基础 - day03/03-code/react-redux-pro-vite/src/store/modules/counterStore.ts

**注意：Redux Toolkit 允许我们在 reducers 写 "可变" 逻辑。它并不是真正的改变状态值，因为它使用了 Immer 库可以检测到“草稿状态“ 的变化并且基于这些变化生产全新的 不可变的状态** 

```ts
import {createSlice, PayloadAction} from "@reduxjs/toolkit"
import {CounterState} from "../interface";

const initialState: CounterState = {
    count: 0
}

const counterSlice = createSlice({
    name: 'counter',
    // 初始化state
    initialState,
    // 修改状态的方法 同步方法 支持直接修改
    reducers: {
        inscrement(state) {
            state.count++
        },
        decrement(state) {
            state.count--
        },
        addToNum(state, action: PayloadAction<number>) {
            state.count = action.payload
        }
    }
})

// 以按需导出的方式导出actionCreator
export const {inscrement, decrement, addToNum} = counterSlice.actions


// 以默认导出的方式导出reducer
export default counterSlice.reducer

```

## 组合store

React 基础 - day03/03-code/react-redux-pro-vite/src/store/index.ts

```ts
import {configureStore} from "@reduxjs/toolkit"
// 导入子模块reducer
import counterReducer from './modules/counterStore'
import channelReducer from './modules/channelStore'
const store = configureStore({
    reducer: {
        counter: counterReducer,
        channel: channelReducer
    }
})

// 从 store 本身推断 `RootState` 和 `AppDispatch` 类型
export type RootState = ReturnType<typeof store.getState>;
// 推断类型：{posts: PostsState, comments: CommentsState, users: UsersState}
export type AppDispatch = typeof store.dispatch;
export default store
```

## 定义全局hooks

React 基础 - day03/03-code/react-redux-pro-vite/src/hooks/storeHooks.ts

```ts
import {TypedUseSelectorHook, useDispatch, useSelector} from 'react-redux';
import {AppDispatch, RootState} from "../store";


// 在整个应用程序中使用，而不是简单的 `useDispatch` 和 `useSelector`
export const useAppDispatch: () => AppDispatch = useDispatch;
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

```

## 全局注入store

React 基础 - day03/03-code/react-redux-pro-vite/src/main.tsx

```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'
import {Provider} from "react-redux";
import store from "./store";

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <Provider store={store}>
            <App/>
        </Provider>
    </React.StrictMode>,
)

```

## @reduxjs/toolkit异步操作

React 基础 - day03/03-code/react-redux-pro-vite/src/store/modules/channelStore.ts

```ts
import {createSlice} from "@reduxjs/toolkit"
import axios from "axios"
import {ChannelState} from "../interface";
import {AppDispatch} from "../index.ts";

const initialState: ChannelState = {
    channelList: []
}

const channelSlice = createSlice({
    name: 'channel',
    initialState,
    reducers: {
        setChannels(state, action) {
            state.channelList = action.payload
        }
    }
})


// 以按需导出的方式导出actionCreator
export const {setChannels} = channelSlice.actions


// 导出异步请求方法
export const fetchChannelList = () => {
    return async (dispatch: AppDispatch) => {
        const res = await axios.get('http://geek.itheima.net/v1_0/channels')
        dispatch(setChannels(res.data.data.channels))
    }
}


export default channelSlice.reducer

```

React 基础 - day03/03-code/react-redux-pro-vite/src/App.tsx

```tsx
import {useEffect} from 'react'
// 导入actionCreator
import {inscrement, decrement, addToNum} from './store/modules/counterStore'
import {fetchChannelList} from './store/modules/channelStore'
import {useAppDispatch, useAppSelector} from "./hooks/storeHooks.ts";

function App() {
    const {count} = useAppSelector(state => state.counter)
    const {channelList} = useAppSelector(state => state.channel)
    const dispatch = useAppDispatch()
    // 使用useEffect触发异步请求执行
    useEffect(() => {
        dispatch(fetchChannelList())
    }, [dispatch])
    return (
        <div className="App">
            <button onClick={() => dispatch(decrement())}>-</button>
            {count}
            <button onClick={() => dispatch(inscrement())}>+</button>
            <button onClick={() => dispatch(addToNum(10))}>add To 10</button>
            <button onClick={() => dispatch(addToNum(20))}>add To 20</button>
            <ul>
                {channelList.map(item => <li key={item.id}>{item.name}</li>)}
            </ul>
        </div>
    )
}

export default App

```

# ReactRouter

## 安装依赖

```powershell
yarn add react-router-dom
```

## 创建路由

React 基础 - day04+day05/03-code/react-router-pro-vite/src/router/index.tsx

```tsx
import {createBrowserRouter} from "react-router-dom";
import Login from "../page/login";
import Article from "../page/Article";

const router = createBrowserRouter([
    {
        path: '/',
        element: <Login/>
    },
    {
        path: '/login',
        element: <Login/>
    },
    {
        path: '/article',
        element: <Article/>
    },
    {
        path: '/article/:id',
        element: <Article/>
    },
    {
        path: '/article/:id/:name',
        element: <Article/>
    }
])

export default router

```

## 全局注入

React 基础 - day04+day05/03-code/react-router-pro-vite/src/App.tsx

```tsx
import {RouterProvider} from "react-router-dom";
import router from "./router";

function App() {
    return (
        <RouterProvider router={router}></RouterProvider>
    )
}

export default App

```

## 路由导航及传参（三种传参两种导航）

React 基础 - day04+day05/03-code/react-router-pro-vite/src/page/login/index.tsx

```tsx
import {Link, useNavigate} from 'react-router-dom'

const Login = () => {
    const navigate = useNavigate()
    return (
        <div>
            我是登录页
            {/* 声明式的写法 */}
            <Link to="/article">跳转到文章页</Link>
            {/* 命令式的写法 */}
            <button onClick={() => navigate('/article')}>跳转到文章页</button>

            <button onClick={() => navigate('/article?id=1001&name=jack')}>searchParams传参</button>
            <button onClick={() => navigate('/article/1001/jack')}>params传参</button>
            <button onClick={() => navigate('/article', {state: {name: 'jhc', id: 1001}})}>state传参</button>
        </div>
    )
}

export default Login

```

React 基础 - day04+day05/03-code/react-router-pro-vite/src/page/Article/index.tsx

```tsx
import {useLocation, useParams, useSearchParams} from "react-router-dom"

const Article = () => {
    // sign searchParams传参
    const [params1] = useSearchParams()
    const id1 = params1.get('id')
    const name1 = params1.get('name')

    // sign params传参
    const params = useParams()
    const id = params.id
    const name = params.name

    // sign state传参
    const location = useLocation()
    const name2 = location.state.name
    const id2 = location.state.id
    return (
        <>
            <div>我是文章页-params传参{id}-{name}</div>
            <div>我是文章页-searchParams传参{id1}-{name1}</div>
            <div>我是文章页-state传参{id2}-{name2}</div>
        </>
    )
}

export default Article

```

## 嵌套路由

React 基础 - day04+day05/03-code/react-router-pro-vite/src/router/index.tsx

```tsx
import {createBrowserRouter} from "react-router-dom";
import Login from "../page/login";
import Article from "../page/Article";
import Layout from "../page/Layout";
import Board from "../page/Board";
import About from "../page/About";
import NotFound from "../page/NotFound";

const router = createBrowserRouter([
    {
        path: '/',
        element: <Layout/>,
        children: [
            {
                // 设置为默认二级路由 一级路由访问的时候，它也能得到渲染
                index: true,
                element: <Board/>
            },
            {
                path: 'about',
                element: <About/>
            }
        ]
    },
    {
        path: '/login',
        element: <Login/>
    },
    {
        path: '/article',
        element: <Article/>
    },
    {
        path: '/article/:id/:name',
        element: <Article/>
    },
    {
        // 404
        path: '*',
        element: <NotFound/>
    }
])

export default router

```

React 基础 - day04+day05/03-code/react-router-pro-vite/src/page/Layout/index.tsx

**一级组件**

```tsx
import {Link, Outlet} from "react-router-dom"

const Layout = () => {
    return (
        <div>
            我是一级路由layout组件
            <br/>
            <Link to="/">面板</Link>
            <Link to="/about">关于</Link>
            
            {/* 配置二级路由的出口 */}
            <Outlet/>
        </div>
    )
}

export default Layout

```

## 两种路由模式

### createBrowserRouter

- 使用HTML5 History API来管理URL，不会在URL中添加`#`。
- 更加美观的URL，不带有冗余的字符。
- 当用户点击浏览器的后退或前进按钮时，React Router会侦听到URL的变化并进行相应的路由渲染。
- 需要服务器配置，以确保在直接访问页面时，相应的路由被正确处理。如果使用React Router的BrowserRouter，而不是HashRouter，并且用户直接访问了某个深层次的路由，服务器需要正确配置以返回正确的HTML页面，而不是404页面。

### createHashRouter

- 在URL中使用`#`来管理路由，例如`http://example.com/#/path`。
- 不需要服务器配置，因为`#`后面的部分被认为是客户端的部分，服务器只需返回初始HTML页面即可。
- 在URL中的`#`部分变化时，不会触发页面刷新，而是会通过JavaScript事件来处理路由的变化。

# 第二种路由写法（旧）

## 创建路由

React 基础 - day04+day05/03-code/react-router-pro-vite-2/src/router/index.tsx

```tsx
import Layout from "../pages/Layout";
import Board from "../pages/Board";
import About from "../pages/About";
import Login from "../pages/login";
import Article from "../pages/Article";
import NotFound from "../pages/NotFound";
import {useRoutes} from "react-router-dom";
import {Expenses} from "../pages/Expenses";
import {Invoices} from "../pages/Invoices";

const rootRouter = [
    {
        path: '/',
        element: <Layout/>,
        children: [
            {
                // 设置为默认二级路由 一级路由访问的时候，它也能得到渲染
                index: true,
                element: <Board/>
            },
            {
                path: 'about',
                element: <About/>
            }
        ]
    },
    {
        path: '/login',
        element: <Login/>
    },
    {
        path: '/expenses',
        element: <Expenses/>
    },
    {
        path: '/invoices',
        element: <Invoices/>
    },
    {
        path: '/article',
        element: <Article/>
    },
    {
        path: '/article/:id/:name',
        element: <Article/>
    },
    {
        // 404
        path: '*',
        element: <NotFound/>
    }
]

const Router = () => {
    return useRoutes(rootRouter);
};

export default Router

```

## 全局注入路由

React 基础 - day04+day05/03-code/react-router-pro-vite-2/src/main.tsx

***无论方法一还是方法二都要嵌套在BrowserRouter或HashRouter下***

```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import {BrowserRouter, Route, Routes} from "react-router-dom";
import {Expenses} from "./pages/Expenses";
import {Invoices} from "./pages/Invoices";
import NotFound from "./pages/NotFound";

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <BrowserRouter>
            {/*sign 下面方法二选一*/}

            {/*方法一*/}
            <App></App>
            <hr/>

            {/*方法二*/}
            <Routes>
                <Route path="/" element={<App/>}>
                    <Route path="expenses" element={<Expenses/>}/>
                    <Route path="invoices" element={<Invoices/>}/>
                </Route>
                <Route path="*" element={<NotFound/>}/>
            </Routes>
        </BrowserRouter>
    </React.StrictMode>,
)

```

## 方法一情况下App需要引入通过useRoutes创建的路由

```tsx
import Router from "./router";
import {Link, Outlet} from "react-router-dom";

function App() {


    return (
        <>
            我是App
            {/*方法一情况下App需要引入通过useRoutes创建的路由*/}
            <Router></Router>

            <h1>Bookkeeper</h1>
            <nav
                style={{
                    borderBottom: "solid 1px",
                    paddingBottom: "1rem"
                }}
            >
                {/*路由跳转*/}
                <Link to="/expenses">Invoices</Link> |{" "}
                <Link to="/invoices">Expenses</Link>
            </nav>

            {/*路由出口*/}
            <Outlet></Outlet>
        </>
    )
}

export default App

```

# 记账本案例

## 项目创建

```powershell
yarn create vite

√ Project name: ... react-bill-vite
? Select a framework: » - Use arrow-keys. Return to submit.
? Select a framework: » - Use arrow-keys. Return to submit.
? Select a framework: » - Use arrow-keys. Return to submit.
? Select a framework: » - Use arrow-keys. Return to submit.
? Select a framework: » - Use arrow-keys. Return to submit.
√ Select a framework: » React
√ Select a variant: » TypeScript + SWC

```

## 安装依赖

```powershell
 yarn add @types/node --dev

yarn add @reduxjs/toolkit react-redux react-router-dom dayjs classnames antd-mobile axios
```

## 配置alias

React 基础 - day04+day05/03-code/react-bill-vite/vite.config.ts

```ts
import {defineConfig} from 'vite'
import react from '@vitejs/plugin-react-swc'
import path from "path";

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [react()],
    resolve: {
        alias: {
            '@': path.resolve(__dirname, './src')
        }
    }
})

```

React 基础 - day04+day05/03-code/react-bill-vite/tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": [
      "ES2020",
      "DOM",
      "DOM.Iterable"
    ],
    "module": "ESNext",
    "skipLibCheck": true,
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": "./src",
    "paths": {
      "@/*": [
        "*"
      ]
    }
  },
  "include": [
    "src"
  ],
  "references": [
    {
      "path": "./tsconfig.node.json"
    }
  ]
}

```



## 配置Redux

React 基础 - day04+day05/03-code/react-bill-vite/src/store/index.ts

```ts
import {configureStore} from '@reduxjs/toolkit'

const store = configureStore({
    reducer: {}
})

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export default store

```

React 基础 - day04+day05/03-code/react-bill-vite/src/hooks/storeHooks.ts

```ts
import {TypedUseSelectorHook, useDispatch, useSelector} from 'react-redux';
import {AppDispatch, RootState} from "../store";


// 在整个应用程序中使用，而不是简单的 `useDispatch` 和 `useSelector`
export const useAppDispatch: () => AppDispatch = useDispatch;
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

```

## 配置Router

React 基础 - day04+day05/03-code/react-bill-vite/src/router/index.tsx

```tsx
import {createBrowserRouter} from "react-router-dom";


const router = createBrowserRouter([])

export default router

```

React 基础 - day04+day05/03-code/react-bill-vite/src/App.tsx

```tsx
import {RouterProvider} from "react-router-dom";
import router from "./router";

function App() {
    return (
        <>
            this is App
            <RouterProvider router={router}></RouterProvider>
        </>
    )
}

export default App

```

