# 项目创建

## webpack

```powershell
npx create-react-app my-app
```

```powershell
 yarn create react-app my-app
```

## vite

```powershell
yarn create vite
```

```powershell
 Project name: ... create-vite-react
√ Select a framework: » React
√ Select a variant: » TypeScript + SWC

Scaffolding project in E:\Study\study\7.React\React 基础 - day01\03-code\create-vite-react...

Done. Now run:

  cd create-vite-react
  yarn
  yarn dev

Done in 28.38s.

```

# useState

`useState` 是 React 中的一个 Hook，它用于在函数组件中添加状态。在 React 中，函数组件之前是无状态的，也就是说它们不能维护任何随时间变化的数据。而通过使用 `useState`，你可以在函数组件中引入状态，使组件能够响应用户的交互和其他事件。

使用方式如下：

```tsx
import React, { useState } from 'react';

// 使用 TypeScript 定义组件的 props
interface ExampleComponentProps {
  initialCount: number;
}

// 使用 React.FC 来定义函数组件，并传入泛型参数定义 props
const ExampleComponent: React.FC<ExampleComponentProps> = ({ initialCount }) => {
  // 使用 useState 定义状态变量 count，类型为 number
  const [count, setCount] = useState<number>(initialCount);

  return (
    <div>
      <p>You clicked {count} times</p>
      {/* 点击按钮时调用 setCount 更新 count 的值 */}
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

export default ExampleComponent;
```

在上面的例子中，`useState` 接受一个初始值作为参数，并返回一个数组。数组的第一个元素是当前状态的值（这里是 `count`），第二个元素是用于更新状态的函数（这里是 `setCount`）。当按钮被点击时，`setCount` 函数被调用，从而更新 `count` 的值，并重新渲染组件。

通过使用 `useState`，你可以在函数组件中保留和更新状态，实现动态的 UI 表现。

# useRef

`useRef` 是 React 中的一个 Hook，用于创建一个可变的对象，其 `current` 属性被初始化为传入的参数。`useRef` 返回的对象在组件的整个生命周期中保持不变，但可以通过修改 `current` 属性来存储和访问任何可变的值。

主要用途包括：

1. **访问 DOM 元素：** 通过将 `useRef` 赋值给组件的 `ref` 属性，可以轻松地访问和操作 DOM 元素。这是一种绕过 React 的虚拟 DOM 直接操作底层 DOM 的方式。

   ```tsx
   import React, { useRef, useEffect } from 'react';
   
   const MyComponent: React.FC = () => {
     const myInputRef = useRef<HTMLInputElement>(null);
   
     useEffect(() => {
       // 在组件挂载后，focus 输入框
       if (myInputRef.current) {
         myInputRef.current.focus();
       }
     }, []);
   
     return <input ref={myInputRef} />;
   };
   ```

2. **保留变量引用：** 在组件重新渲染时，`useRef` 返回的对象保持不变，这意味着可以在多次渲染之间共享同一引用，而不会导致重新创建。

   ```tsx
   import React, { useRef } from 'react';
   
   const MyComponent: React.FC = () => {
     const countRef = useRef(0);
   
     // 在组件每次重新渲染时增加计数
     countRef.current += 1;
   
     return <p>Render count: {countRef.current}</p>;
   };
   ```

总的来说，`useRef` 提供了一种在函数组件中存储和访问持久化数据的方式，而不需要触发组件的重新渲染。

# useMemo

`useMemo` 是 React 中的一个 Hook，用于对计算昂贵的值进行缓存，以避免在每次渲染时重新计算。它的主要目的是优化性能，特别是在处理大型数据集或执行复杂的计算时。

`useMemo` 接受两个参数：一个是计算函数，另一个是依赖数组。它返回计算函数的结果，并将该结果缓存起来。只有当依赖数组中的值发生变化时，`useMemo` 才会重新计算。

下面是一个简单的例子，演示了使用 `useMemo` 来计算并缓存斐波那契数列：

```tsx
import React, { useMemo, useState } from 'react';

const FibonacciCalculator: React.FC = () => {
  const [number, setNumber] = useState(1);

  // 使用 useMemo 缓存计算结果
  const fibonacciResult = useMemo(() => {
    const calculateFibonacci = (n: number): number => {
      if (n <= 1) {
        return n;
      }
      return calculateFibonacci(n - 1) + calculateFibonacci(n - 2);
    };

    return calculateFibonacci(number);
  }, [number]); // 依赖数组包含 number，只有 number 发生变化时才重新计算

  return (
    <div>
      <input
        type="number"
        value={number}
        onChange={(e) => setNumber(parseInt(e.target.value, 10))}
      />
      <p>Fibonacci of {number} is {fibonacciResult}</p>
    </div>
  );
};
```

在这个例子中，斐波那契数列的计算是一个昂贵的操作。通过使用 `useMemo`，我们确保只有 `number` 改变时才会重新计算斐波那契数列的值，从而避免不必要的计算。这对于优化性能和提高应用的响应速度特别有用。

# useCallback与React.memo

`useCallback` 和 `React.memo` 是一对常常一同使用的 React 优化工具，特别是在处理性能敏感的应用场景时。

1. **`useCallback`：** 主要用于缓存回调函数，以避免在每次组件渲染时重新创建回调函数。通过在 `useCallback` 中指定依赖数组，你可以确保相同的函数引用在依赖不变的情况下不会被重新创建。这对于避免不必要的子组件渲染以及提高性能非常有用。

   ```tsx
   const memoizedCallback = useCallback(
     () => {
       // callback logic
     },
     [dependencies]
   );
   ```

2. **`React.memo`：** 用于封装函数组件，以便在组件的 `props` 没有变化时防止不必要的重新渲染。它接收一个组件作为参数，并返回一个新的组件，该新组件仅在 `props` 发生变化时重新渲染。

   ```tsx
   const MemoizedComponent = React.memo(MyComponent);
   ```

在实际应用中，通常结合使用 `useCallback` 和 `React.memo`，特别是在父组件中使用 `useCallback` 缓存回调函数，然后将其传递给子组件，并使用 `React.memo` 包裹子组件以防止不必要的重新渲染。

```tsx
const ParentComponent: React.FC = () => {
  const handleClick = useCallback(() => {
    // handle click logic
  }, []);

  return (
    <div>
      <ChildComponent onClick={handleClick} />
    </div>
  );
};

const ChildComponent: React.FC<{ onClick: () => void }> = React.memo(({ onClick }) => {
  console.log('ChildComponent rendering');
  return <button onClick={onClick}>Click me</button>;
});
```

这样可以确保在父组件重新渲染时，由于使用了 `useCallback`，传递给 `ChildComponent` 的 `onClick` 属性引用保持不变，同时由于使用了 `React.memo`，`ChildComponent` 只在 `props` 发生变化时才会重新渲染。这有助于提高整体应用的性能。

`useCallback` 是 React 中的一个 Hook，它用于缓存回调函数，以避免在每次渲染时创建新的回调函数。主要目的是优化性能，特别是在将回调函数传递给子组件时，避免触发不必要的重新渲染。

当父组件重新渲染时，其子组件可能会因为接收到新的回调函数而重新渲染，即使这个新函数的逻辑与之前的函数相同。通过使用 `useCallback`，你可以确保相同的回调函数实例在多次渲染之间保持不变。

**下面是一个简单的例子**，演示了使用`useCallback` 和 `React.memo` 的情况：

```tsx
import React, {memo, useCallback, useState} from 'react';

const ChildComponent: React.FC<{ onClick: () => void }> = memo(({onClick}) => {
    console.log('ChildComponent rendering');
    return <button onClick={onClick}>Click me</button>;
});

const ChildComponent2: React.FC<{ onClick: () => void }> = ({onClick}) => {
    console.log('ChildComponent2 rendering');
    return <button onClick={onClick}>Click me2</button>;
};

const ChildComponent3: React.FC<{ onClick: () => void }> = ({onClick}) => {
    console.log('ChildComponent3 rendering');
    return <button onClick={onClick}>Click me3</button>;
};

const ParentComponent: React.FC = () => {
    const [count, setCount] = useState(0);

    // 使用 useCallback 缓存回调函数
    const handleClick = useCallback(() => {
        setCount((prevCount) => prevCount + 1);
    }, []); // 空的依赖数组表示这个回调函数没有依赖，不会因为任何变量的变化而重新创建

    const handleClick2 = () => {
        setCount((prevCount) => prevCount + 1);
    }
    return (
        <div>
            <p>Clicked {count} times</p>
            {/* 将缓存的回调函数传递给子组件 */}
            <ChildComponent onClick={handleClick}/>
            <ChildComponent2 onClick={handleClick}/>
            <ChildComponent3 onClick={handleClick2}/>
        </div>
    );
};


export default ParentComponent

```

在这个例子中，`handleClick` 是一个处理点击事件的回调函数。通过使用`useCallback` 和 `React.memo` ，我们确保在 `ParentComponent` 重新渲染时，`handleClick` 的引用保持不变，从而避免了不必要的 `ChildComponent` 重新渲染。

注意：只有当你发现通过创建新的回调函数引起了性能问题时，才需要使用 `useCallback` 进行优化。在大多数情况下，React 的性能优化机制可以很好地处理这种情况，而不需要手动缓存回调函数。

# useEffect

`useEffect` 是 React 中的一个 Hook，用于处理副作用操作。在 React 组件中，副作用指的是那些不直接与渲染 UI 相关的操作，例如数据获取、订阅或手动操作 DOM。

`useEffect` 的主要用途是在函数组件中执行一些副作用操作，并且可以在组件的生命周期中指定何时进行这些操作。它接受两个参数：第一个是包含副作用代码的函数，第二个是一个依赖数组，用于指定何时触发副作用操作。

基本语法如下：

```tsx
useEffect(() => {
  // 副作用操作
  return () => {
    // 清理操作（可选）
  };
}, [dependencies]);
```

- 第一个参数是一个函数，包含需要执行的副作用代码。
- 第二个参数是一个依赖数组，包含影响副作用执行的变量。如果省略，副作用会在每次组件渲染时都执行；如果传递一个空数组 `[]`，副作用只会在组件挂载和卸载时执行；如果依赖数组包含变量，副作用将在这些变量发生变化时执行。

以下是 `useEffect` 的一些常见用途：

1. **数据获取和订阅：** 使用 `useEffect` 来获取数据、订阅外部事件或执行其他异步操作。

   ```tsx
   useEffect(() => {
     // 数据获取或订阅逻辑
     fetchData();
     
     return () => {
       // 在组件卸载时进行清理
       unsubscribe();
     };
   }, [dependencies]);
   ```

2. **手动操作 DOM：** 使用 `useEffect` 在组件挂载后或更新后执行手动操作 DOM 的代码。

   ```tsx
   useEffect(() => {
     // 手动操作 DOM 的逻辑
     const element = document.getElementById('myElement');
     element?.classList.add('highlighted');
   
     return () => {
       // 在组件卸载或更新前进行清理
       element?.classList.remove('highlighted');
     };
   }, [dependencies]);
   ```

3. **定时器和计时器：** 使用 `useEffect` 来设置和清理定时器或计时器。

   ```tsx
   useEffect(() => {
     // 设置定时器
     const timerId = setInterval(() => {
       // 定时器逻辑
     }, 1000);
   
     return () => {
       // 在组件卸载或更新前清理定时器
       clearInterval(timerId);
     };
   }, [dependencies]);
   ```

总之，`useEffect` 提供了一种在函数组件中处理副作用的机制，有助于确保这些副作用不会影响到 React 的渲染流程，并且可以在合适的时机执行和清理。

# createContext和useContext

`createContext` 和 `useContext` 是 React 中用于处理全局状态（或者说在组件树中跨多个组件传递数据）的 API。它们通常结合使用，但有不同的作用。

1. **`createContext`：** 该函数用于创建一个全局的上下文对象。这个上下文对象包含两个组件：`Provider` 和 `Consumer`。

   ```tsx
   const MyContext = React.createContext();
   ```

   `MyContext` 包含两个属性：`Provider` 和 `Consumer`。`Provider` 用于在组件树中的某个地方提供共享的数据，而 `Consumer` 用于在组件树中的其他地方访问这个数据。通常，`Provider` 会在父组件中使用，而 `Consumer` 会在子孙组件中使用。

2. **`useContext`：** 该 Hook 用于在函数组件中访问上下文对象的值。它接收一个上下文对象（通过 `createContext` 创建的）作为参数，并返回当前上下文的值。

   ```tsx
   const myContextValue = useContext(MyContext);
   ```

   `useContext` 会在组件渲染时读取 `MyContext` 的当前值，而这个值是由最近的 `MyContext.Provider` 提供的。如果没有匹配的 `Provider`，`useContext` 将使用 `MyContext` 的默认值。

下面是一个简单的例子，演示如何使用 `createContext` 和 `useContext` 传递和获取全局状态：

```tsx
import {createContext, Dispatch, FC, ReactNode, SetStateAction, useContext, useState} from 'react';

// 定义上下文值的类型
interface MyContextType {
    globalState: string;
    setGlobalState: Dispatch<SetStateAction<string>>;
}

interface ParentComponent {
    children: ReactNode
}

// 创建上下文对象并指定默认值
const MyContext = createContext<MyContextType | undefined>(undefined);

// 父组件，提供全局状态
const ParentComponent: FC<ParentComponent> = ({children}) => {
    const [globalState, setGlobalState] = useState<string>('Initial Value');

    return (
        <MyContext.Provider value={{globalState, setGlobalState}}>
            {children}
        </MyContext.Provider>
    );
};

// 子组件，使用全局状态
const ChildComponent: FC = () => {
    // 使用useContext获取上下文值
    const {globalState, setGlobalState} = useContext(MyContext)!; // 需要使用感叹号表示我们确定上下文值不为undefined

    const handleClick = () => {
        setGlobalState('New Value');
    };

    return (
        <div>
            <p>Global State: {globalState}</p>
            <button onClick={handleClick}>Update Global State</button>
        </div>
    );
};

// 在父组件中使用子组件
const App: FC = () => {
    return (
        <ParentComponent>
            <ChildComponent/>
        </ParentComponent>
    );
};


export default App;

```

在这个例子中，`ParentComponent` 通过 `MyContext.Provider` 提供了一个包含 `globalState` 和 `setGlobalState` 的值对象。然后，`ChildComponent` 使用 `useContext(MyContext)` 来获取这些值，并能够更新全局状态。

# 自定义hooks


在React中，自定义Hook是一种用于封装可复用逻辑的机制。它允许你将组件之间共享的状态逻辑提取到可重用的函数中，从而使代码更易于维护和组织。

自定义Hook的命名一般以"use"开头，以表明它是一个Hook。自定义Hook可以使用React的基本Hooks（如useState、useEffect等）以及其他自定义Hook，以创建具有复杂逻辑的组件。

以下是一个简单的例子，演示了一个自定义Hook的使用：

```tsx
import { useState, useEffect } from 'react';

// 自定义Hook，用于获取窗口的宽度和高度
function useWindowDimensions() {
  const [windowDimensions, setWindowDimensions] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    // 监听窗口变化
    const handleResize = () => {
      setWindowDimensions({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    // 添加事件监听器
    window.addEventListener('resize', handleResize);

    // 在组件卸载时清除事件监听器
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []); // 传递一个空数组表示仅在组件挂载和卸载时执行

  // 返回窗口尺寸
  return windowDimensions;
}

// 使用自定义Hook的组件
function MyComponent() {
  const { width, height } = useWindowDimensions();

  return (
    <div>
      Window Width: {width}, Window Height: {height}
    </div>
  );
}
```

在这个例子中，`useWindowDimensions` 是一个自定义Hook，它封装了获取窗口宽度和高度的逻辑。`MyComponent` 组件使用这个Hook来获取窗口尺寸并显示在页面上。这样，窗口尺寸的逻辑被抽象到一个独立的函数中，可以在任何需要获取窗口尺寸的组件中重复使用。

# 组件通信

## 父传子props

在React中，"props"（属性）是一种机制，用于从父组件向子组件传递数据。父组件可以通过props将数据传递给子组件，从而影响或配置子组件的行为和渲染。

具体来说，父组件可以在子组件标签上的属性中设置数据，子组件通过props对象接收这些属性。以下是一个简单的示例：

```tsx
// 父传子
// 1. 父组件传递数据  子组件标签身上绑定属性
// 2. 子组件接收数据  props的参数

// 子组件 Son
import {type ReactNode} from "react";

interface SonProps {
    name: string;
    age: number;
    isTrue: boolean;
    list: string[];
    obj: { name: string };
    cb: () => void;
    child: ReactNode;
}

function Son(props: SonProps) {
    // props：对象里面包含了父组件传递过来的所有的数据
    // { name:'父组件中的数据'}
    console.dir(props)
    return <div>this is son, {props.name}, jsx: {props.child}</div>
}


function App() {
    const name = 'this is App name'
    return (
        <div>
            <Son
                name={name}
                age={18}
                isTrue={false}
                list={['vue', 'react']}
                obj={{name: 'jack'}}
                cb={() => console.log(123)}
                child={<span>this is span</span>}
            />
        </div>
    )
}

export default App
```

这是React中使用props实现父传子数据的基本模式。props不仅可以传递基本的数据类型，还可以传递函数、对象等。 Props的传递是单向的，即从父组件流向子组件，而不能直接在子组件中修改props。

## 子传父自定义事件

```tsx
// 核心：在子组件中调用父组件中的函数并传递实参

import {useState} from "react"

interface SonProps {
    onGetSonMsg: (msg: string) => void
}


function Son(props: SonProps) {
    const {onGetSonMsg} = props
    // Son组件中的数据
    const sonMsg = 'this is son msg'
    return (
        <div>
            this is Son
            <button onClick={() => onGetSonMsg(sonMsg)}>sendMsg</button>
        </div>
    )
}

function App() {
    const [msg, setMsg] = useState('')
    const getMsg = (msg: string) => {
        console.log(msg)
        setMsg(msg)
    }
    return (
        <div>
            this is App, {msg}
            <Son onGetSonMsg={getMsg}/>
        </div>
    )
}

export default App

```

## 状态提升兄弟组件通信

```tsx
// 1. 通过子传父 A -> App
// 2. 通过父传子 App -> B

import {useState} from "react"

interface AProps {
    onGetAName: (name: string) => void
}

interface BProps {
    name: string
}


function A(props: AProps) {
    const {onGetAName} = props
    // Son组件中的数据
    const name = 'this is A name'
    return (
        <div>
            this is A component,
            <button onClick={() => onGetAName(name)}>send</button>
        </div>
    )
}

function B(props: BProps) {
    const {name} = props
    return (
        <div>
            this is B component,
            {name}
        </div>
    )
}

function App() {
    const [name, setName] = useState('')
    const getAName = (name: string) => {
        console.log(name)
        setName(name)
    }
    return (
        <div>
            this is App
            <A onGetAName={getAName}/>
            <B name={name}/>
        </div>
    )
}

export default App

```

## context跨层通信

```tsx
// App -> A -> B

import {createContext, useContext} from "react"

// 1. createContext方法创建一个上下文对象

const MsgContext = createContext('')

// 2. 在顶层组件 通过Provider组件提供数据

// 3. 在底层组件 通过useContext钩子函数使用数据

function A() {
    return (
        <div>
            this is A component
            <B/>
        </div>
    )
}

function B() {
    const msg = useContext(MsgContext)
    return (
        <div>
            this is B component,{msg}
        </div>
    )
}

function App() {
    const msg = 'this is app msg'
    return (
        <div>
            <MsgContext.Provider value={msg}>
                this is App
                <A/>
            </MsgContext.Provider>
        </div>
    )
}

export default App

```

# Redux

## 创建项目

```powershell
yarn create vite
success Installed "create-vite@5.2.1" with binaries:
      - create-vite
      - cva
√ Project name: ... react-redux-pro-vite
? Select a framework: » - Use arrow-keys. Return to submit.
>   Vanilla
    Vue
√ Select a framework: » React
√ Select a variant: » TypeScript + SWC

Scaffolding project in E:\Study\study\7.React\React 基础 - day03\03-code\react-redux-pro-vite...

Done. Now run:

  cd react-redux-pro-vite
  yarn
  yarn dev

Done in 245.47s.

```

## 安装Redux所需依赖

```powershell
yarn add @reduxjs/toolkit react-redux
```

## 创建子store使用@reduxjs/toolkit

React 基础 - day03/03-code/react-redux-pro-vite/src/store/modules/counterStore.ts

**注意：Redux Toolkit 允许我们在 reducers 写 "可变" 逻辑。它并不是真正的改变状态值，因为它使用了 Immer 库可以检测到“草稿状态“ 的变化并且基于这些变化生产全新的 不可变的状态** 

```ts
import {createSlice, PayloadAction} from "@reduxjs/toolkit"
import {CounterState} from "../interface";

const initialState: CounterState = {
    count: 0
}

const counterSlice = createSlice({
    name: 'counter',
    // 初始化state
    initialState,
    // 修改状态的方法 同步方法 支持直接修改
    reducers: {
        inscrement(state) {
            state.count++
        },
        decrement(state) {
            state.count--
        },
        addToNum(state, action: PayloadAction<number>) {
            state.count = action.payload
        }
    }
})

// 以按需导出的方式导出actionCreator
export const {inscrement, decrement, addToNum} = counterSlice.actions


// 以默认导出的方式导出reducer
export default counterSlice.reducer

```

## 组合store

React 基础 - day03/03-code/react-redux-pro-vite/src/store/index.ts

```ts
import {configureStore} from "@reduxjs/toolkit"
// 导入子模块reducer
import counterReducer from './modules/counterStore'
import channelReducer from './modules/channelStore'
const store = configureStore({
    reducer: {
        counter: counterReducer,
        channel: channelReducer
    }
})

// 从 store 本身推断 `RootState` 和 `AppDispatch` 类型
export type RootState = ReturnType<typeof store.getState>;
// 推断类型：{posts: PostsState, comments: CommentsState, users: UsersState}
export type AppDispatch = typeof store.dispatch;
export default store
```

## 定义全局hooks

React 基础 - day03/03-code/react-redux-pro-vite/src/hooks/storeHooks.ts

```ts
import {TypedUseSelectorHook, useDispatch, useSelector} from 'react-redux';
import {AppDispatch, RootState} from "../store";


// 在整个应用程序中使用，而不是简单的 `useDispatch` 和 `useSelector`
export const useAppDispatch: () => AppDispatch = useDispatch;
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

```

## 全局注入store

React 基础 - day03/03-code/react-redux-pro-vite/src/main.tsx

```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'
import {Provider} from "react-redux";
import store from "./store";

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <Provider store={store}>
            <App/>
        </Provider>
    </React.StrictMode>,
)

```

## @reduxjs/toolkit异步操作

React 基础 - day03/03-code/react-redux-pro-vite/src/store/modules/channelStore.ts

```ts
import {createAsyncThunk, createSlice} from "@reduxjs/toolkit"
import axios from "axios"
import {ChannelState} from "../interface";
import {AppDispatch} from "../index.ts";

const initialState: ChannelState = {
    channelList: []
}

const channelSlice = createSlice({
    name: 'channel',
    initialState,
    reducers: {
        setChannels(state, action) {
            state.channelList = action.payload
        }
    }
})


// 以按需导出的方式导出actionCreator
export const {setChannels} = channelSlice.actions


// 导出异步请求方法
export const fetchChannelList = () => {
    return async (dispatch: AppDispatch) => {
        const res = await axios.get('http://geek.itheima.net/v1_0/channels')
        dispatch(setChannels(res.data.data.channels))
    }
}

export const fetchChannelListAsync = createAsyncThunk('channel/fetchChannelList',
    async (_, {dispatch}) => {
        try {
            const res = await axios.get('http://geek.itheima.net/v1_0/channels')
            dispatch(setChannels(res.data.data.channels))

        } catch (e) {
            console.log(e, 'fetchChannelListAsync')
            throw e
        }

    }
)


export default channelSlice.reducer

```

React 基础 - day03/03-code/react-redux-pro-vite/src/App.tsx

```tsx
import {useEffect} from 'react'
// 导入actionCreator
import {inscrement, decrement, addToNum} from './store/modules/counterStore'
import {fetchChannelList} from './store/modules/channelStore'
import {useAppDispatch, useAppSelector} from "./hooks/storeHooks.ts";

function App() {
    const {count} = useAppSelector(state => state.counter)
    const {channelList} = useAppSelector(state => state.channel)
    const dispatch = useAppDispatch()
    // 使用useEffect触发异步请求执行
    useEffect(() => {
        dispatch(fetchChannelList())
    }, [dispatch])
    return (
        <div className="App">
            <button onClick={() => dispatch(decrement())}>-</button>
            {count}
            <button onClick={() => dispatch(inscrement())}>+</button>
            <button onClick={() => dispatch(addToNum(10))}>add To 10</button>
            <button onClick={() => dispatch(addToNum(20))}>add To 20</button>
            <ul>
                {channelList.map(item => <li key={item.id}>{item.name}</li>)}
            </ul>
        </div>
    )
}

export default App

```

# ReactRouter

## 安装依赖

```powershell
yarn add react-router-dom
```

## 创建路由

React 基础 - day04+day05/03-code/react-router-pro-vite/src/router/index.tsx

```tsx
import {createBrowserRouter} from "react-router-dom";
import Login from "../page/login";
import Article from "../page/Article";

const router = createBrowserRouter([
    {
        path: '/',
        element: <Login/>
    },
    {
        path: '/login',
        element: <Login/>
    },
    {
        path: '/article',
        element: <Article/>
    },
    {
        path: '/article/:id',
        element: <Article/>
    },
    {
        path: '/article/:id/:name',
        element: <Article/>
    }
])

export default router

```

## 全局注入

React 基础 - day04+day05/03-code/react-router-pro-vite/src/App.tsx

```tsx
import {RouterProvider} from "react-router-dom";
import router from "./router";

function App() {
    return (
        <RouterProvider router={router}></RouterProvider>
    )
}

export default App

```

## 路由导航及传参（三种传参两种导航）

React 基础 - day04+day05/03-code/react-router-pro-vite/src/page/login/index.tsx

```tsx
import {Link, useNavigate} from 'react-router-dom'

const Login = () => {
    const navigate = useNavigate()
    return (
        <div>
            我是登录页
            {/* 声明式的写法 */}
            <Link to="/article">跳转到文章页</Link>
            {/* 命令式的写法 */}
            <button onClick={() => navigate('/article')}>跳转到文章页</button>

            <button onClick={() => navigate('/article?id=1001&name=jack')}>searchParams传参</button>
            <button onClick={() => navigate('/article/1001/jack')}>params传参</button>
            <button onClick={() => navigate('/article', {state: {name: 'jhc', id: 1001}})}>state传参</button>
        </div>
    )
}

export default Login

```

React 基础 - day04+day05/03-code/react-router-pro-vite/src/page/Article/index.tsx

```tsx
import {useLocation, useParams, useSearchParams} from "react-router-dom"

const Article = () => {
    // sign searchParams传参
    const [params1] = useSearchParams()
    const id1 = params1.get('id')
    const name1 = params1.get('name')

    // sign params传参
    const params = useParams()
    const id = params.id
    const name = params.name

    // sign state传参
    const location = useLocation()
    const name2 = location.state.name
    const id2 = location.state.id
    return (
        <>
            <div>我是文章页-params传参{id}-{name}</div>
            <div>我是文章页-searchParams传参{id1}-{name1}</div>
            <div>我是文章页-state传参{id2}-{name2}</div>
        </>
    )
}

export default Article

```

## 嵌套路由

React 基础 - day04+day05/03-code/react-router-pro-vite/src/router/index.tsx

```tsx
import {createBrowserRouter} from "react-router-dom";
import Login from "../page/login";
import Article from "../page/Article";
import Layout from "../page/Layout";
import Board from "../page/Board";
import About from "../page/About";
import NotFound from "../page/NotFound";

const router = createBrowserRouter([
    {
        path: '/',
        element: <Layout/>,
        children: [
            {
                // 设置为默认二级路由 一级路由访问的时候，它也能得到渲染
                index: true,
                element: <Board/>
            },
            {
                path: 'about',
                element: <About/>
            }
        ]
    },
    {
        path: '/login',
        element: <Login/>
    },
    {
        path: '/article',
        element: <Article/>
    },
    {
        path: '/article/:id/:name',
        element: <Article/>
    },
    {
        // 404
        path: '*',
        element: <NotFound/>
    }
])

export default router

```

React 基础 - day04+day05/03-code/react-router-pro-vite/src/page/Layout/index.tsx

**一级组件**

```tsx
import {Link, Outlet} from "react-router-dom"

const Layout = () => {
    return (
        <div>
            我是一级路由layout组件
            <br/>
            <Link to="/">面板</Link>
            <Link to="/about">关于</Link>
            
            {/* 配置二级路由的出口 */}
            <Outlet/>
        </div>
    )
}

export default Layout

```

## 两种路由模式

### createBrowserRouter

- 使用HTML5 History API来管理URL，不会在URL中添加`#`。
- 更加美观的URL，不带有冗余的字符。
- 当用户点击浏览器的后退或前进按钮时，React Router会侦听到URL的变化并进行相应的路由渲染。
- 需要服务器配置，以确保在直接访问页面时，相应的路由被正确处理。如果使用React Router的BrowserRouter，而不是HashRouter，并且用户直接访问了某个深层次的路由，服务器需要正确配置以返回正确的HTML页面，而不是404页面。

### createHashRouter

- 在URL中使用`#`来管理路由，例如`http://example.com/#/path`。
- 不需要服务器配置，因为`#`后面的部分被认为是客户端的部分，服务器只需返回初始HTML页面即可。
- 在URL中的`#`部分变化时，不会触发页面刷新，而是会通过JavaScript事件来处理路由的变化。

# 第二种路由写法（旧）

## 创建路由

React 基础 - day04+day05/03-code/react-router-pro-vite-2/src/router/index.tsx

```tsx
import Layout from "../pages/Layout";
import Board from "../pages/Board";
import About from "../pages/About";
import Login from "../pages/login";
import Article from "../pages/Article";
import NotFound from "../pages/NotFound";
import {useRoutes} from "react-router-dom";
import {Expenses} from "../pages/Expenses";
import {Invoices} from "../pages/Invoices";

const rootRouter = [
    {
        path: '/',
        element: <Layout/>,
        children: [
            {
                // 设置为默认二级路由 一级路由访问的时候，它也能得到渲染
                index: true,
                element: <Board/>
            },
            {
                path: 'about',
                element: <About/>
            }
        ]
    },
    {
        path: '/login',
        element: <Login/>
    },
    {
        path: '/expenses',
        element: <Expenses/>
    },
    {
        path: '/invoices',
        element: <Invoices/>
    },
    {
        path: '/article',
        element: <Article/>
    },
    {
        path: '/article/:id/:name',
        element: <Article/>
    },
    {
        // 404
        path: '*',
        element: <NotFound/>
    }
]

const Router = () => {
    return useRoutes(rootRouter);
};

export default Router

```

## 全局注入路由

React 基础 - day04+day05/03-code/react-router-pro-vite-2/src/main.tsx

***无论方法一还是方法二都要嵌套在BrowserRouter或HashRouter下***

```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import {BrowserRouter, Route, Routes} from "react-router-dom";
import {Expenses} from "./pages/Expenses";
import {Invoices} from "./pages/Invoices";
import NotFound from "./pages/NotFound";

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <BrowserRouter>
            {/*sign 下面方法二选一*/}

            {/*方法一*/}
            <App></App>
            <hr/>

            {/*方法二*/}
            <Routes>
                <Route path="/" element={<App/>}>
                    <Route path="expenses" element={<Expenses/>}/>
                    <Route path="invoices" element={<Invoices/>}/>
                </Route>
                <Route path="*" element={<NotFound/>}/>
            </Routes>
        </BrowserRouter>
    </React.StrictMode>,
)

```

## 方法一情况下App需要引入通过useRoutes创建的路由

```tsx
import Router from "./router";
import {Link, Outlet} from "react-router-dom";

function App() {


    return (
        <>
            我是App
            {/*方法一情况下App需要引入通过useRoutes创建的路由*/}
            <Router></Router>

            <h1>Bookkeeper</h1>
            <nav
                style={{
                    borderBottom: "solid 1px",
                    paddingBottom: "1rem"
                }}
            >
                {/*路由跳转*/}
                <Link to="/expenses">Invoices</Link> |{" "}
                <Link to="/invoices">Expenses</Link>
            </nav>

            {/*路由出口*/}
            <Outlet></Outlet>
        </>
    )
}

export default App

```

# 记账本案例

## 项目创建

```powershell
yarn create vite

√ Project name: ... react-bill-vite
? Select a framework: » - Use arrow-keys. Return to submit.
? Select a framework: » - Use arrow-keys. Return to submit.
? Select a framework: » - Use arrow-keys. Return to submit.
? Select a framework: » - Use arrow-keys. Return to submit.
? Select a framework: » - Use arrow-keys. Return to submit.
√ Select a framework: » React
√ Select a variant: » TypeScript + SWC

```

## 安装依赖

```powershell
 yarn add @types/node --dev

 yarn add @reduxjs/toolkit react-redux react-router-dom dayjs classnames antd-mobile axios sass lodash
 
 yarn add @types/lodash --dev
```

## 配置alias

React 基础 - day04+day05/03-code/react-bill-vite/vite.config.ts

```ts
import {defineConfig} from 'vite'
import react from '@vitejs/plugin-react-swc'
import path from "path";

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [react()],
    resolve: {
        alias: {
            '@': path.resolve(__dirname, './src')
        }
    }
})

```

React 基础 - day04+day05/03-code/react-bill-vite/tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": [
      "ES2020",
      "DOM",
      "DOM.Iterable"
    ],
    "module": "ESNext",
    "skipLibCheck": true,
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": "./src",
    "paths": {
      "@/*": [
        "*"
      ]
    }
  },
  "include": [
    "src"
  ],
  "references": [
    {
      "path": "./tsconfig.node.json"
    }
  ]
}

```



## 配置Redux

### 基础配置

React 基础 - day04+day05/03-code/react-bill-vite/src/store/index.ts

```ts
import {configureStore} from '@reduxjs/toolkit'

const store = configureStore({
    reducer: {}
})

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export default store

```

React 基础 - day04+day05/03-code/react-bill-vite/src/hooks/storeHooks.ts

```ts
import {TypedUseSelectorHook, useDispatch, useSelector} from 'react-redux';
import {AppDispatch, RootState} from "../store";


// 在整个应用程序中使用，而不是简单的 `useDispatch` 和 `useSelector`
export const useAppDispatch: () => AppDispatch = useDispatch;
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

```

### 全局注入

React 基础 - day04+day05/03-code/react-bill-vite/src/main.tsx

```tsx
// import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './main.scss'
import './theme.scss'
import {Provider} from "react-redux";
import store from "@/store";

ReactDOM.createRoot(document.getElementById('root')!).render(
    // <React.StrictMode>
    <Provider store={store}>
        <App/>
    </Provider>
    // </React.StrictMode>,
)

```

## 配置Router

React 基础 - day04+day05/03-code/react-bill-vite/src/router/index.tsx

```tsx
import {createBrowserRouter} from "react-router-dom";


const router = createBrowserRouter([])

export default router

```

React 基础 - day04+day05/03-code/react-bill-vite/src/App.tsx

```tsx
import {RouterProvider} from "react-router-dom";
import router from "./router";

function App() {
    return (
        <>
            this is App
            <RouterProvider router={router}></RouterProvider>
        </>
    )
}

export default App

```

## 配置Mock

### 安装依赖

```powershell
 yarn add json-server
 yarn add concurrently --dev
```

### 配置启动项

```json
  "scripts": {
    "start": "tsc && concurrently \"npm run server\" \"vite\"",
    "dev": "tsc vite",
    "server": "json-server ./server/data.json --port 8888",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
```

## 路由设计

### Lottie组件封装

React 基础 - day04+day05/03-code/react-bill-vite/src/components/Lottie.tsx

```tsx
import {useLottie} from "lottie-react";
import {CSSProperties, FC} from "react";

interface Props {
    animation: unknown
    initStyle?: CSSProperties
    loop?: boolean
    autoplay?: boolean
    rendererType?: 'svg' | 'canvas' | 'html'
}


const Lottie: FC<Props> = ({animation, initStyle, loop = true, autoplay = true, rendererType = 'svg'}) => {
    const defaultOptions = {
        loop: loop,
        autoplay: autoplay,
        animationData: animation,
        rendererSettings: {
            preserveAspectRatio: "xMidYMid slice",
        },
    };
    const style = {
        height: '100px',
        width: '100px',
        ...initStyle,
    }

    const {View: lottie} = useLottie<typeof rendererType>(defaultOptions, style);

    return (
        <>
            {lottie}
        </>
    )
}

export default Lottie
```

### 路由懒加载组件

React 基础 - day04+day05/03-code/react-bill-vite/src/router/utils/lazyLoad/lazyLoad.tsx

```tsx
import React, {ComponentType, Suspense} from "react";
import './lazyLoad.scss'
import Lottie from "@/components/Lottie.tsx";
import animation from "@/json/loading1.json"

/**
 * @description 路由懒加载
 * @param {ComponentType} Comp 需要访问的组件
 * @returns React.ReactNode
 */
const LazyLoad = (Comp: ComponentType): React.ReactNode => {
    const LoadingIndicator = (
        <div className='lazy-load-container'>
            <Lottie animation={animation}/>
        </div>
    );

    return (
        <Suspense fallback={LoadingIndicator}>
            <Comp/>
        </Suspense>
    );
};

export default LazyLoad;

```

### 路由结构

React 基础 - day04+day05/03-code/react-bill-vite/src/router/index.tsx

```tsx
import {createBrowserRouter} from "react-router-dom";

import lazyLoad from "@/router/utils/lazyLoad/lazyLoad.tsx";
import React from "react";


const router = createBrowserRouter([
    {
        path: '/',
        element: lazyLoad(React.lazy(() => import("@/pages/Layout"))),
        children: [
            {
                index: true,
                element: lazyLoad(React.lazy(() => import("@/pages/Month"))),
            },
            {
                path: 'year',
                element: lazyLoad(React.lazy(() => import("@/pages/Year"))),
            }
        ]
    },
    {
        path: '/new',
        element: lazyLoad(React.lazy(() => import("@/pages/New")))
    }
])

export default router

```

## antd-mobile主题定制

### 全局样式文件

React 基础 - day04+day05/03-code/react-bill-vite/src/theme.scss

```scss
:root:root {
  --adm-color-primary: rgb(105, 174, 120);
}

.purple {
  --adm-color-primary: #a062d4;
}

```

### 全局导入

React 基础 - day04+day05/03-code/react-bill-vite/src/main.tsx

```tsx
// import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './main.scss'
import './theme.scss'

ReactDOM.createRoot(document.getElementById('root')!).render(
    // <React.StrictMode>
    <App/>
    // </React.StrictMode>,
)

```

## Redux管理账目列表（模块化）

### 创建切片

React 基础 - day04+day05/03-code/react-bill-vite/src/store/module/bill/billSlice.ts

```ts
import {createSlice, PayloadAction} from '@reduxjs/toolkit';
import {BillItem, BillState} from '@/store/interface';

const initialState: BillState = {
    billList: []
}

const billSlice = createSlice({
    name: 'bill',
    initialState,
    reducers: {
        setBillList(state, action) {
            state.billList = action.payload
        },
        addBill(state, action: PayloadAction<BillItem>) {
            state.billList.push(action.payload)
        }
    }
});

export const {setBillList, addBill} = billSlice.actions;
export default billSlice.reducer;

```

### 创建异步action

React 基础 - day04+day05/03-code/react-bill-vite/src/store/module/bill/ billAsyncActions.ts

```ts
import {AppDispatch} from '@/store';
import {addBill, setBillList} from './billSlice';
import axios from 'axios';
import {BillItem} from "@/store/interface";
import {Toast} from "antd-mobile";
import {createAsyncThunk} from "@reduxjs/toolkit";

export const getBillList = () => {
    return async (dispatch: AppDispatch) => {
        try {
            const res = await axios.get('http://localhost:8888/ka');
            dispatch(setBillList(res.data));
        } catch (error) {
            console.error('Error fetching bill list:', error);
        }
    }
}

export const getBillListAsync = createAsyncThunk(
    'bill/getBillList',
    async (_, {dispatch}) => {
        try {
            const res = await axios.get('http://localhost:8888/ka');
            dispatch(setBillList(res.data));
            return;
        } catch (error) {
            // 处理错误
            console.error('Error getting billList:', error);
            throw error;
        }
    }
)

export const addBillList = (data: BillItem) => {
    return async (dispatch: AppDispatch) => {
        try {
            Toast.show({
                icon: 'loading',
            })
            const res = await axios.post('http://localhost:8888/ka', data);
            dispatch(addBill(res.data));
            Toast.show({
                icon: 'success',
                content: '保存成功',
            })
        } catch (error) {
            console.error('Error adding bill:', error);
        }
    }
}

// 创建异步 thunk
export const addBillListAsync = createAsyncThunk(
    'bill/addBillList',
    async (data: BillItem, {dispatch}) => {
        try {
            // 发送请求
            const res = await axios.post('http://localhost:8888/ka', data);
            // 返回数据
            dispatch(addBill(res.data));
            return;
        } catch (error) {
            // 处理错误
            console.error('Error adding bill:', error);
            throw error;
        }
    }
);


```

### 引入切片

React 基础 - day04+day05/03-code/react-bill-vite/src/store/index.ts

```ts
import {configureStore} from '@reduxjs/toolkit'
import billSlice from '@/store/module/bill/billSlice'

const store = configureStore({
    reducer: {
        bill: billSlice
    }
})

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export default store

```

## TabBar功能实现

React 基础 - day04+day05/03-code/react-bill-vite/src/pages/Layout/index.tsx

```tsx
import {TabBar} from "antd-mobile"
import {useEffect} from "react"
import {Outlet, useLocation, useNavigate} from "react-router-dom"
import './index.scss'
import {
    BillOutline,
    CalculatorOutline,
    AddCircleOutline
} from 'antd-mobile-icons'
import {getBillList} from "@/store/module/bill/ billAsyncActions.ts";
import {useAppDispatch} from "@/hooks/storeHooks.ts";

const tabs = [
    {
        key: '/month',
        title: '月度账单',
        icon: <BillOutline/>,
    },
    {
        key: '/new',
        title: '记账',
        icon: <AddCircleOutline/>,
    },
    {
        key: '/year',
        title: '年度账单',
        icon: <CalculatorOutline/>,
    },
]

const Layout = () => {
    const dispatch = useAppDispatch()
    const navigate = useNavigate()
    const location = useLocation()

    
    useEffect(() => {
        dispatch(getBillList())
    }, [dispatch])

    // tabBar 路由跳转
    const switchRoute = (path: string) => {
        navigate(path)
    }
    return (
        <div className="layout">
            <div className="container">
                <Outlet/>
            </div>
            <div className="footer">
                <TabBar activeKey={location.pathname} onChange={switchRoute}>
                    {tabs.map(item => (
                        <TabBar.Item key={item.key} icon={item.icon} title={item.title}/>
                    ))}
                </TabBar>
            </div>
        </div>
    )
}

export default Layout

```

## 月度账单-统计区域

```tsx
import {NavBar, DatePicker} from 'antd-mobile'
import './index.scss'
import {useCallback, useEffect, useMemo, useState} from "react";
import classNames from "classnames";
import dayjs from "dayjs"
import {useAppSelector} from "@/hooks/storeHooks.ts";
import _ from 'lodash'
import {BillItem} from "@/store/interface";

const Month = () => {
    const [dateVisible, setDateVisible] = useState(false)
    const [currentMonth, setCurrentMonth] = useState(() => {
        return dayjs().format('YYYY-MM')
    })
    const [currentMonthList, setMonthList] = useState<BillItem[]>([])
    const billList = useAppSelector(state => state.bill.billList)

    const monthGroup = useMemo(() => {
        return _.groupBy(billList, item => dayjs(item.date).format('YYYY-MM'))
    }, [billList])


    // 时间选择框确实事件 useCallback 防止冲渲染时更新引用
    const dateConfirm = useCallback((date: Date) => {
        const formattedDate = dayjs(date).format('YYYY-MM')
        setDateVisible(false)
        setCurrentMonth(formattedDate)
        setMonthList(monthGroup[formattedDate] || [])
    }, [setDateVisible, setCurrentMonth, setMonthList, monthGroup]);

    // 计算统计
    const overview = useMemo(() => {
        const income = currentMonthList.filter(item => item.type === 'income')
            .reduce((a, c) => a + c.money, 0)
        const pay = currentMonthList.filter(item => item.type === 'pay')
            .reduce((a, c) => a + c.money, 0)
        return {
            income,
            pay,
            total: income + pay
        }
    }, [currentMonthList])

    // 首次加载
    useEffect(() => {
        dateConfirm(new Date())
    }, [dateConfirm, monthGroup])

    return (
        <div className="monthlyBill">
            <NavBar className="nav" backArrow={false}>
                月度收支
            </NavBar>
            <div className="content">
                <div className="header">
                    {/* 时间切换区域 */}
                    <div className="date" onClick={() => setDateVisible(true)}>
            <span className="text">
              {currentMonth}月账单
            </span>
                        <span className={classNames('arrow', {expand: dateVisible})}></span>
                    </div>
                    {/* 统计区域 */}
                    <div className='twoLineOverview'>
                        <div className="item">
                            <span className="money">{overview.pay || '无'}</span>
                            <span className="type">支出</span>
                        </div>
                        <div className="item">
                            <span className="money">{overview.income || '无'}</span>
                            <span className="type">收入</span>
                        </div>
                        <div className="item">
                            <span className="money">{overview.total || '无'}</span>
                            <span className="type">结余</span>
                        </div>
                    </div>
                    {/* 时间选择器 */}
                    <DatePicker
                        className="kaDate"
                        title="记账日期"
                        precision="month"
                        visible={dateVisible}
                        max={new Date()}
                        onConfirm={dateConfirm}
                        onClose={() => setDateVisible(false)}
                        onCancel={() => setDateVisible(false)}
                    />
                </div>
            </div>
        </div>
    )
}

export default Month

```

## 自定义支出，收入，结余总结hook

React 基础 - day04+day05/03-code/react-bill-vite/src/hooks/useDayResult.ts

```ts
import dayjs from 'dayjs';
import {BillItem} from "@/store/interface";
import {useMemo} from "react";


const getDatResult = (billList: BillItem[]) => {
    const pay = billList.filter((item) => item.type === 'pay').reduce((a, c) => a + c.money, 0);
    const income = billList.filter((item) => item.type === 'income').reduce((a, c) => a + c.money, 0);
    return {
        pay,
        income,
        total: pay + income,
    };
};

export const useYearResult = (billList: BillItem[]) => {
    return useMemo(() => {
        return getDatResult(billList)
    }, [billList]);
};

export const useMonthResult = (data: BillItem[], maxMonth: number) => {
    return useMemo(() => {
        return Array.from({length: maxMonth}, (_, monthIndex) => {
            const monthData = data.filter(item => monthIndex === dayjs(item.date).get('month'));
            return getDatResult(monthData);
        });
    }, [data, maxMonth])
};
```

## 月度账单-列表区域-单日账单列表

React 基础 - day04+day05/03-code/react-bill-vite/src/pages/Month/components/DayBill/index.tsx

```ts
import classNames from 'classnames'
import './index.scss'
import {FC} from "react";
import {BillItem} from "@/store/interface";
import useDayResult from "@/hooks/useDayResult.ts";

interface Props {
    date: string
    billList: BillItem[]
}

const DailyBill: FC<Props> = ({date, billList}) => {

    const dayResult = useDayResult(billList)

    return (
        <div className={classNames('dailyBill')}>
            <div className="header">
                <div className="dateIcon">
                    <span className="date">{date}</span>
                    <span className={classNames('arrow')}></span>
                </div>
                <div className="oneLineOverview">
                    <div className="pay">
                        <span className="type">支出</span>
                        <span className="money">{dayResult.pay.toFixed(2) || '无'}</span>
                    </div>
                    <div className="income">
                        <span className="type">收入</span>
                        <span className="money">{dayResult.income.toFixed(2) || '无'}</span>
                    </div>
                    <div className="balance">
                        <span className="money">{dayResult.total.toFixed(2) || '无'}</span>
                        <span className="type">结余</span>
                    </div>
                </div>
            </div>
        </div>
    )
}
export default DailyBill

```

## 月度账单-列表区域-单日账单详情列表

### 封装Icon组件

React 基础 - day04+day05/03-code/react-bill-vite/src/components/Icon/index.tsx

```tsx
import {CSSProperties, FC} from "react";

interface Props {
    type: string
    initStyle?: CSSProperties
    className?: string
}

const Icon: FC<Props> = ({type, initStyle, className}) => {
    const style = {
        height: '20px',
        width: '20px',
        ...initStyle,
    }
    return (
        <img
            src={`https://yjy-teach-oss.oss-cn-beijing.aliyuncs.com/reactbase/ka/${type}.svg`}
            alt="icon"
            style={style}
            className={className}
        />
    )
}

export default Icon

```

### 页面完成

React 基础 - day04+day05/03-code/react-bill-vite/src/pages/Month/components/DayBill/index.tsx

```tsx
import classNames from 'classnames'
import './index.scss'
import {FC, useState} from "react";
import {BillItem} from "@/store/interface";
import useDayResult from "@/hooks/useDayResult.ts";
import {billTypeToName} from "@/contants";
import Icon from "@/components/Icon";

interface Props {
    date: string
    billList: BillItem[]
}

const DailyBill: FC<Props> = ({date, billList}) => {

    const dayResult = useDayResult(billList)
    const [visible, setVisible] = useState(false)

    return (
        <div className={classNames('dailyBill')}>
            <div className="header">
                <div className="dateIcon">
                    <span className="date">{date}</span>
                    <span className={classNames('arrow', {expand: visible})}
                          onClick={() => setVisible(!visible)}></span>
                </div>
                <div className="oneLineOverview">
                    <div className="pay">
                        <span className="type">支出</span>
                        <span className="money">{dayResult.pay.toFixed(2) || '无'}</span>
                    </div>
                    <div className="income">
                        <span className="type">收入</span>
                        <span className="money">{dayResult.income.toFixed(2) || '无'}</span>
                    </div>
                    <div className="balance">
                        <span className="money">{dayResult.total.toFixed(2) || '无'}</span>
                        <span className="type">结余</span>
                    </div>
                </div>
            </div>
            {/* 单日列表 */}
            <div className="billList" style={{display: !visible ? 'none' : undefined}}>
                {billList.map(item => {
                    return (
                        <div className="bill" key={item.id}>
                            <Icon type={item.useFor}/>
                            <div className="detail">
                                <div className="billType">{billTypeToName[item.useFor]}</div>
                            </div>
                            <div className={classNames('money', item.type)}>
                                {item.money.toFixed(2)}
                            </div>
                        </div>
                    )
                })}
            </div>
        </div>
    )
}
export default DailyBill

```

## 新增账单功能实现

```tsx
import {Button, DatePicker, Input, NavBar} from 'antd-mobile'
import Icon from '@/components/Icon'
import './index.scss'
import classNames from 'classnames'
import {billListData} from '@/contants'
import {useNavigate} from 'react-router-dom'
import {useEffect, useState} from "react";
import {useAppDispatch} from "@/hooks/storeHooks.ts";
import {addBillList} from "@/store/module/bill/ billAsyncActions.ts";
import dayjs from "dayjs";

const New = () => {
    const navigate = useNavigate()
    const [billType, setBillType] = useState('pay')
    const [money, setMoney] = useState(0)
    const [useFor, setUseFor] = useState('')
    const [dateVisible, setDateVisible] = useState(false)
    const [currentDate, setCurrentDate] = useState(dayjs(new Date()).format('YYYY-MM-DD'))

    useEffect(() => {
        setUseFor(billListData[billType][0].list[0].type)
    }, [billType]);

    const dispatch = useAppDispatch()
    const moneyChange = (value: string) => {
        setMoney(Number(value))
    }
    const saveBill = () => {
        const data = {
            type: billType,
            money: billType === 'pay' ? -money : +money,
            date: currentDate,
            useFor: useFor
        }
        dispatch(addBillList(data))
    }

    const dateConfirm = (date: Date) => {
        setCurrentDate(dayjs(date).format('YYYY-MM-DD'))
    }

    return (
        <div className="keepAccounts">
            <NavBar className="nav" onBack={() => navigate(-1)}>
                记一笔
            </NavBar>

            <div className="header">
                <div className="kaType">
                    <Button
                        shape="rounded"
                        className={classNames({selected: billType === 'pay'})}
                        onClick={() => setBillType('pay')}
                    >
                        支出
                    </Button>
                    <Button
                        className={classNames({selected: billType === 'income'})}
                        shape="rounded"
                        onClick={() => setBillType('income')}
                    >
                        收入
                    </Button>
                </div>

                <div className="kaFormWrapper">
                    <div className="kaForm">
                        <div onClick={() => setDateVisible(true)} className="date">
                            <Icon type="calendar" className="icon"/>
                            <span className="text">{currentDate}</span>
                            {/*时间选择器*/}
                            <DatePicker
                                className="kaDate"
                                title="记账日期"
                                max={new Date()}
                                visible={dateVisible}
                                onConfirm={dateConfirm}
                                onClose={() => setDateVisible(false)}
                                onCancel={() => setDateVisible(false)}
                            />
                        </div>
                        <div className="kaInput">
                            <Input
                                value={String(money)}
                                onChange={moneyChange}
                                className="input"
                                placeholder="0.00"
                                type="number"
                            />
                            <span className="iconYuan">¥</span>
                        </div>
                    </div>
                </div>
            </div>

            <div className="kaTypeList">
                {billListData[billType].map(item => {
                    return (
                        <div className="kaType" key={item.type}>
                            <div className="title">{item.name}</div>
                            <div className="list">
                                {item.list.map(item => {
                                    return (
                                        <div
                                            className={classNames('item', {active: useFor === item.type})}
                                            key={item.type}
                                            onClick={() => setUseFor(item.type)}
                                        >
                                            <div className="icon">
                                                <Icon type={item.type}/>
                                            </div>
                                            <div className="text">{item.name}</div>
                                        </div>
                                    )
                                })}
                            </div>
                        </div>
                    )
                })}
            </div>

            <div className="btns">
                <Button onClick={saveBill} className="btn save">
                    保 存
                </Button>
            </div>
        </div>
    )
}

export default New

```

## 自定义时间选择hook

React 基础 - day04+day05/03-code/react-bill-vite/src/hooks/useDate.ts

```ts
import {useCallback, useState} from 'react';
import dayjs from 'dayjs';
import isToday from 'dayjs/plugin/isToday';

dayjs.extend(isToday);

export const useDate = (format: string) => {
    const [date, setDate] = useState(new Date());
    const [visible, setVisible] = useState(false);

    const onShowDate = useCallback(() => setVisible(true), []);
    const onHideDate = useCallback(() => setVisible(false), []);
    const onDateChange = useCallback((val: Date) => setDate(val), []);

    return {
        dayjsDate: dayjs(date),
        selectedDate: dayjs(date).format(format),
        visible,
        onShowDate,
        onHideDate,
        onDateChange,
    };
};

```

## 自定义获取记账列表hook

React 基础 - day04+day05/03-code/react-bill-vite/src/hooks/useBillList.ts

```ts
import {useCallback, useEffect, useMemo} from 'react'
import dayjs from 'dayjs'

import {getBillListAsync} from '@/store/module/bill/ billAsyncActions.ts'
import {useAppDispatch, useAppSelector} from "@/hooks/storeHooks.ts";

//返回所有账单
export const useBillList = () => {
    const dispatch = useAppDispatch();
    const billList = useAppSelector(state => state.bill.billList);

    const apiGetBillList = useCallback(async () => {
        await dispatch(getBillListAsync());
    }, [dispatch]);

    useEffect(() => {
        apiGetBillList();
    }, [apiGetBillList]);


    return billList;
};

// 返回选择年账单
export const useYearBillList = (selectedYear: string) => {
    const billList = useAppSelector(state => state.bill.billList)

    return useMemo(() => {
        return billList.filter(item => selectedYear === dayjs(item.date).get('year').toString())
    }, [billList, selectedYear]);
}

```

# 极客项目

## 项目创建

```powershell
yarn create vite react-ts-vite-jike
```

## 配置别名(tsconfig.json也要配置)

vite.config.ts

```ts
import {defineConfig} from 'vite'
import react from '@vitejs/plugin-react-swc'
import path from "path";

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [react()],
    resolve: {
        alias: {
            '@': path.resolve(__dirname, './src')
        }
    },
    server: {
        open: true,
        host: '0.0.0.0'
    }
})

```

tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": [
      "ES2020",
      "DOM",
      "DOM.Iterable"
    ],
    "module": "ESNext",
    "skipLibCheck": true,
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    /* 别名配置 */
    "baseUrl": "./src",
    "paths": {
      "@/*": [
        "*"
      ]
    }
  },
  "include": [
    "src"
  ],
  "references": [
    {
      "path": "./tsconfig.node.json"
    }
  ]
}

```

## 安装依赖

```powershell
yarn add eslint sass antd lottie-react react-router-dom axios react-redux  redux-persist normalize.css
yarn add @types/node @types/redux-persist @types/redux-logger @reduxjs/toolkit  --dev
```

## 路由创建

### 懒加载组件

src/router/utils/lazyLoad/lazyLoad.tsx

```tsx
import React, {ComponentType, Suspense} from "react";
import './lazyLoad.scss'	
import Lottie from '../../../components/Lottie/index.tsx'
import animation from '../../../json/loading1.json'

/**
 * @description 路由懒加载
 * @param {ComponentType} Comp 需要访问的组件
 * @returns React.ReactNode
 */
const LazyLoad = (Comp: ComponentType): React.ReactNode => {
    const LoadingIndicator = (
        <div className='lazy-load-container'>
            <Lottie animation={animation}/>
        </div>
    );

    return (
        <Suspense fallback={LoadingIndicator}>
            <Comp/>
        </Suspense>
    );
};

export default LazyLoad;
```

### 创建路由Router

src/router/index.tsx

```tsx
import {createBrowserRouter} from "react-router-dom";


import {lazy} from "react";
import lazyLoad from "./utils/lazyLoad/lazyLoad.tsx";


const router = createBrowserRouter([
    {
        path: '/layout',
        element: lazyLoad(lazy(() => import("../pages/Layout/index.tsx")))
    },
    {
        path: '/login',
        element: lazyLoad(lazy(() => import("../pages/Login/index.tsx")))
    }
])

export default router

```

### 全局注入路由

src/App.tsx

```tsx
import {RouterProvider} from "react-router-dom";
import router from "./router";

function App() {


    return (
        <>
            <RouterProvider router={router}></RouterProvider>
        </>
    )
}

export default App

```

## Redux配置

### 基础配置

src/store/index.ts

```ts
import {configureStore} from '@reduxjs/toolkit'

const store = configureStore({
    reducer: {}
})

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export default store

```

### 配置全局hooks

src/hooks/storeHooks.ts

```ts
import {TypedUseSelectorHook, useDispatch, useSelector} from 'react-redux';
import {AppDispatch, RootState} from "@/store";


// 在整个应用程序中使用，而不是简单的 `useDispatch` 和 `useSelector`
export const useAppDispatch: () => AppDispatch = useDispatch;
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

```

### 全局注入

src/main.tsx

```tsx
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './main.scss'
import {Provider} from "react-redux";
import store from "@/store";


ReactDOM.createRoot(document.getElementById('root')!).render(
    <Provider store={store}>
        <App/>
    </Provider>
)

```

## 封装Axios

src/util/request.ts

```ts
import axios from 'axios'

const http = axios.create({
    baseURL: import.meta.env.VITE_APP_BASE_URL,
    timeout: 5000
})

// 添加请求拦截器
http.interceptors.request.use((config) => {
    return config
}, (error) => {
    return Promise.reject(error)
})

// 添加响应拦截器
http.interceptors.response.use((response) => {
    // 2xx 范围内的状态码都会触发该函数。
    // 对响应数据做点什么
    return response.data
}, (error) => {
    // 超出 2xx 范围的状态码都会触发该函数。
    // 对响应错误做点什么
    return Promise.reject(error.response.data)
})

export default http

```

src/apis/index.ts

```ts
import {instance} from '@/util/index.ts'

export interface ApiResult<T> {
    status: number
    success: boolean
    message: string
    data: T
    error?: Error
    token?: string
}

export async function get<T>(url: string, params?: any): Promise<ApiResult<T>> {
    const response = await instance.get<ApiResult<T>>(url, {params})
    return response.data
}

export async function post<T>(url: string, data?: any): Promise<ApiResult<T>> {
    const response = await instance.post<ApiResult<T>>(url, data)
    return response.data
}

export async function put<T>(url: string, data?: any): Promise<ApiResult<T>> {
    const response = await instance.put<ApiResult<T>>(url, data)
    return response.data
}

export async function del<T>(url: string, params?: any): Promise<ApiResult<T>> {
    const response = await instance.delete<ApiResult<T>>(url, {params})
    return response.data
}

```

## Antd配置主题色

src/App.tsx

```tsx
import {RouterProvider} from "react-router-dom";
import router from "./router";
import {ConfigProvider} from "antd";

function App() {


    return (
        <>
            <ConfigProvider theme={{
                token: {
                    // Seed Token，影响范围大
                    colorPrimary: '#69AE78FF',
                    borderRadius: 4,

                    // 派生变量，影响范围小
                    colorBgContainer: '#f6ffed',
                },
            }}>
                <RouterProvider router={router}></RouterProvider>
            </ConfigProvider>
        </>
    )
}

export default App

```

## Redux日志中间件

src/store/utils/logger.ts

```ts
import {createLogger, LoggerPredicate} from 'redux-logger';


// 日志配置对象
interface LoggerConfig {
    predicate: LoggerPredicate;
    collapsed: boolean;
    duration: boolean;
    timestamp: boolean;
    level: 'log' | 'warn' | 'error' | 'info';
}

// 排除不记录的
const shouldExcludeAction = (actionType: string): boolean => {
    const excludedKeywords = ['persist'];
    return !excludedKeywords.some(keyword => actionType.includes(keyword));
};


// 日志配置对象
const loggerConfig: LoggerConfig = {
    // 记录除特定类型的操作之外的所有内容
    predicate: (_, action) => shouldExcludeAction(action.type),
    // 折叠日志
    collapsed: true,
    // 打印每个动作的持续时间
    duration: true,
    // 打印每个操作的时间戳
    timestamp: true,
    // 日志级别 'log' | 'warn' | 'error' | 'info',
    level: 'info',
};

const logger = createLogger(loggerConfig);

export default logger;

```

## Redux持久化

### store配置

src/store/index.ts

```ts
import {combineReducers, configureStore, Middleware} from '@reduxjs/toolkit'
import userSlice from "./module/user/userSlice.ts";
import {FLUSH, PAUSE, PERSIST, persistReducer, persistStore, PURGE, REGISTER, REHYDRATE,} from "redux-persist";
import storage from "redux-persist/lib/storage";
import logger from "./utils/logger.ts";

const rootReducer = combineReducers({
    user: userSlice
})


// 持久化配置
const persistConfig = {
    key: "root",
    storage,
    // 白名单
    whitelist: ['user']
};

const middlewares: Middleware[] = []
if (process.env.NODE_ENV === 'development') middlewares.push(logger);

const persistedReducer = persistReducer(persistConfig, rootReducer);

const store = configureStore({
    reducer: persistedReducer,
    middleware: (getDefaultMiddleware) =>
        getDefaultMiddleware({
            serializableCheck: {
                // 关闭序列化检查
                ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER]
            },
        }).concat(middlewares)
})
export const persistor = persistStore(store);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export default store

```

### 全局注入

```ts
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './main.scss'
import {Provider} from "react-redux";
import store, {persistor} from "@/store";
import {PersistGate} from "redux-persist/integration/react";


ReactDOM.createRoot(document.getElementById('root')!).render(
    <Provider store={store}>
        {/*等待 Redux store 中的持久化数据加载完成后再渲染应用*/}
        <PersistGate loading={null} persistor={persistor}>
            <App/>
        </PersistGate>
    </Provider>
)
```

## 登录模块

### 准备静态结构

src/pages/Login/index.tsx

```tsx
import './index.scss'
import {Button, Card, Form, Input} from 'antd'
import logo from '@/assets/logo.png'

const Login = () => {
    return (
        <div className="login">
            <Card className="login-container">
                <img className="login-logo" src={logo} alt=""/>
                {/* 登录表单 */}
                <Form>
                    <Form.Item>
                        <Input size="large" placeholder="请输入手机号"/>
                    </Form.Item>
                    <Form.Item>
                        <Input size="large" placeholder="请输入验证码"/>
                    </Form.Item>
                    <Form.Item>
                        <Button type="primary" htmlType="submit" size="large" block>
                            登录
                        </Button>
                    </Form.Item>
                </Form>
            </Card>
        </div>
    )
}

export default Login

```

### 增加表单校验

```tsx
import './index.scss'
import {Button, Card, Form, Input} from 'antd'
import logo from '@/assets/logo.png'
import {FC} from "react";

interface FieldType {
    phone?: string;
    code?: string;
}

const Login: FC = () => {
    return (
        <div className="login">
            <Card className="login-container">
                <img className="login-logo" src={logo} alt=""/>
                {/* 登录表单 */}
                <Form>
                    <Form.Item<FieldType> name='phone' validateTrigger="onBlur"
                                          rules={[
                                              {required: true, message: '请输入手机号'},
                                              {
                                                  pattern: /^1[3-9]\d{9}$/,
                                                  message: '请输入正确的手机号'
                                              }
                                          ]}>
                        <Input size="large" placeholder="请输入手机号"/>
                    </Form.Item>
                    <Form.Item<FieldType> name='code' validateTrigger="onBlur"
                                          rules={[{required: true, message: '请输入验证码'}]}>
                        <Input size="large" placeholder="请输入验证码"/>
                    </Form.Item>
                    <Form.Item>
                        <Button type="primary" htmlType="submit" size="large" block>
                            登录
                        </Button>
                    </Form.Item>
                </Form>
            </Card>
        </div>
    )
}

export default Login

```

### 收集表单数据

```tsx
import './index.scss'
import {Button, Card, Form, Input} from 'antd'
import logo from '@/assets/logo.png'
import {FC} from "react";

interface FieldType {
    phone?: string;
    code?: string;
}

const Login: FC = () => {
    const formConfirm = (formData: Required<FieldType>) => {
        console.log(formData)
    }

    return (
        <div className="login">
            <Card className="login-container">
                <img className="login-logo" src={logo} alt=""/>
                {/* 登录表单 */}
                <Form onFinish={formConfirm}>
                    <Form.Item<FieldType> name='phone' validateTrigger="onBlur"
                                          rules={[
                                              {required: true, message: '请输入手机号'},
                                              {
                                                  pattern: /^1[3-9]\d{9}$/,
                                                  message: '请输入正确的手机号'
                                              }
                                          ]}>
                        <Input size="large" placeholder="请输入手机号"/>
                    </Form.Item>
                    <Form.Item<FieldType> name='code' validateTrigger="onBlur"
                                          rules={[{required: true, message: '请输入验证码'}]}>
                        <Input size="large" placeholder="请输入验证码"/>
                    </Form.Item>
                    <Form.Item>
                        <Button type="primary" htmlType="submit" size="large" block>
                            登录
                        </Button>
                    </Form.Item>
                </Form>
            </Card>
        </div>
    )
}

export default Login

```

### redux管理token

#### 创建storeSlice

src/store/module/user/userSlice.ts

```ts
import {createSlice} from '@reduxjs/toolkit';
import {LoginInfo} from "@/store/interface";
import {loginThunk} from "@/store/module/user/userAsyncActions.ts";

const initialState: LoginInfo = {
    token: '',
    userInfo: {}
}


const userSlice = createSlice({
    name: 'bill',
    initialState,
    reducers: {
        setUserInfo(state, action) {
            state.userInfo = action.payload
        },
        setUserToken(state, action) {
            state.token = action.payload
        }
    },
    extraReducers: (builder) => {
        builder.addCase(loginThunk.rejected, (_, action) => {
            throw new Error(action.error.message)
        })
    }
});

export const {setUserInfo, setUserToken} = userSlice.actions;
export default userSlice.reducer;

```

#### 创建异步action

src/store/module/user/userAsyncActions.ts

```ts
import {createAsyncThunk} from "@reduxjs/toolkit";
import {setUserToken} from "@/store/module/user/userSlice.ts";
import {LoginForm} from "@/store/interface";
import {login} from "@/apis/modules/login.ts";


export const loginThunk = createAsyncThunk('user/login',
    async (loginForm: Required<LoginForm>, {dispatch}) => {
        const res = await login(loginForm)
        dispatch(setUserToken(res.data.token))
        return
    }
)

```

### 封装message自定义hook

src/hooks/useMessage.tsx

```tsx
import {message} from 'antd';
import {ReactNode, useCallback} from 'react';

import {CloseOutlined} from '@ant-design/icons'

const useMessage = () => {
    const [messageApi, contextHolder] = message.useMessage();

    const showMessage = useCallback(
        async (type: 'success' | 'error' | 'info' | 'warning' | 'loading', content: ReactNode, duration: number = 3, onClose?: () => void) => {
            await messageApi[type]({
                content: <span>
                    <span style={{marginRight: '10px'}}>{content}</span>
                    <CloseOutlined className={'CloseOutlined'} style={{cursor: "pointer"}}
                                   onClick={() => messageApi.destroy()}/>
                </span>,
                duration,
                onClose,
            });
        },
        [messageApi]
    );

    return {
        messageApi,
        contextHolder,
        showSuccess: useCallback((content: ReactNode, duration?: number, onClose?: () => void) => showMessage('success', content, duration, onClose), [
            showMessage,
        ]),
        showError: useCallback((content: ReactNode, duration?: number, onClose?: () => void) => showMessage('error', content, duration, onClose), [
            showMessage,
        ]),
        showInfo: useCallback((content: ReactNode, duration?: number, onClose?: () => void) => showMessage('info', content, duration, onClose), [showMessage]),
        showWarning: useCallback((content: ReactNode, duration?: number, onClose?: () => void) => showMessage('warning', content, duration, onClose), [
            showMessage,
        ]),
        showLoading: useCallback((content: ReactNode, duration?: number, onClose?: () => void) => showMessage('loading', content, duration, onClose), [showMessage])
    };
};

export default useMessage;

```

### 登录按钮绑定

src/pages/Login/index.tsx

```tsx
import './index.scss'
import {Button, Card, Form, Input} from 'antd'
import logo from '@/assets/logo.png'
import {FC, useState} from "react";
import {loginThunk} from "@/store/module/user/userAsyncActions.ts";
import {useAppDispatch} from "@/hooks/storeHooks.ts";
import {LoginForm} from "@/store/interface";
import useMessage from "@/hooks/useMessage.tsx";


const Login: FC = () => {
    const dispatch = useAppDispatch()
    const [loading, setLoading] = useState(false)
    const {showError, showSuccess, contextHolder} = useMessage();

    const formConfirm = async (formData: Required<LoginForm>) => {
        try {
            setLoading(true)
            await dispatch(loginThunk(formData))
            showSuccess('登陆成功')
        } catch (e: any) {
            e.message && showError(e.message)
            console.dir(e, 'formConfirm')
        } finally {
            setLoading(false)
        }

    }

    return (
        <div className="login">
            {contextHolder}
            <Card className="login-container">
                <img className="login-logo" src={logo} alt=""/>
                {/* 登录表单 */}
                <Form onFinish={formConfirm}>
                    <Form.Item<Partial<LoginForm>> name='mobile' validateTrigger="onBlur"
                                                   rules={[
                                                       {required: true, message: '请输入手机号'},
                                                       {
                                                           pattern: /^1[3-9]\d{9}$/,
                                                           message: '请输入正确的手机号'
                                                       }
                                                   ]}>
                        <Input size="large" placeholder="请输入手机号"/>
                    </Form.Item>
                    <Form.Item<Partial<LoginForm>> name='code' validateTrigger="onBlur"
                                                   rules={[{required: true, message: '请输入验证码'}]}>
                        <Input size="large" placeholder="请输入验证码"/>
                    </Form.Item>
                    <Form.Item>
                        <Button loading={loading} type="primary" htmlType="submit" size="large" block>
                            登录
                        </Button>
                    </Form.Item>
                </Form>
            </Card>
        </div>
    )
}

export default Login

```

### Token持久化

src/store/index.ts

```ts
import {combineReducers, configureStore, Middleware} from '@reduxjs/toolkit'
import userSlice from "./module/user/userSlice.ts";
import {FLUSH, PAUSE, PERSIST, persistReducer, persistStore, PURGE, REGISTER, REHYDRATE,} from "redux-persist";
import storage from "redux-persist/lib/storage";
import logger from "./utils/logger.ts";

const rootReducer = combineReducers({
    user: userSlice
})


// 持久化配置
const persistConfig = {
    key: "root",
    storage,
    // 白名单
    whitelist: ['user']
};

const middlewares: Middleware[] = []
if (process.env.NODE_ENV === 'development') middlewares.push(logger);

const persistedReducer = persistReducer(persistConfig, rootReducer);

const store = configureStore({
    reducer: persistedReducer,
    middleware: (getDefaultMiddleware) =>
        getDefaultMiddleware({
            serializableCheck: {
                // 关闭序列化检查
                ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER]
            },
        }).concat(middlewares)
})
export const persistor = persistStore(store);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export default store

```

### 封装useToken自定义hook

```ts
import {useAppDispatch, useAppSelector} from "@/hooks/storeHooks.ts";
import {useCallback} from "react";
import {setUserToken} from "@/store/module/user/userSlice.ts";

const useToken = () => {
    const dispatch = useAppDispatch()
    const token = useAppSelector(state => state.user.token)

    const setToken = useCallback((token: string) => {
        dispatch(setUserToken(token))
    }, [dispatch])

    const clearToken = useCallback(() => {
        setToken('')
    }, [setToken])
    return {
        token,
        setToken,
        clearToken
    }
}

export default useToken

```

### 请求头注入Token

```ts
import axios from 'axios'
import {getToken} from "@/util/storage.ts";

const http = axios.create({
    baseURL: import.meta.env.VITE_APP_BASE_URL,
    timeout: 5000
})

// 添加请求拦截器
http.interceptors.request.use((config) => {
    const token = getToken()
    if (token) config.headers.Authorization = `Bearer ${token}`
    return config
}, (error) => {
    return Promise.reject(error)
})

// 添加响应拦截器
http.interceptors.response.use((response) => {
    // 2xx 范围内的状态码都会触发该函数。
    // 对响应数据做点什么
    return response
}, (error) => {
    // 超出 2xx 范围的状态码都会触发该函数。
    // 对响应错误做点什么
    return Promise.reject(error.response.data)
})

export default http

```

### 根据Token控制路由跳转

#### 封装高阶组件

src/router/utils/AuthRoute/index.tsx

```tsx
import {Navigate} from "react-router-dom";
import React from "react";
import useToken from "@/hooks/useToken.ts";

const AuthRoute = (props: { children: React.ReactNode }): React.ReactNode => {
    const {token} = useToken()
    if (token) {
        return props.children
    } else {
        return <Navigate to="/login" replace/>
    }
}

export default AuthRoute

```

#### 创建懒加载路由中转导出

src/router/LazyLoadWrapper.tsx

```tsx
import {lazy} from "react";
import LazyLoad from "./utils/LazyLoad";

const Layout = LazyLoad(lazy(() => import("@/pages/Layout/index.tsx")));
const Login = LazyLoad(lazy(() => import("@/pages/Login/index.tsx")))

export {
    Layout,
    Login
}

```

#### 路由使用

src/router/index.tsx

```tsx
import {createBrowserRouter} from "react-router-dom";
import AuthRoute from "@/router/utils/AuthRoute";
import {Layout, Login} from "@/router/LazyLoadWrapper.tsx";


const router = createBrowserRouter([
    {
        path: '/',
        element: <AuthRoute>{Layout}</AuthRoute>
    },
    {
        path: '/login',
        element: Login
    }
])

export default router

```

## Layout模块

### 准备静态结构

src/pages/Layout/index.tsx

```tsx
import {Layout, Menu, Popconfirm} from 'antd'
import {DiffOutlined, EditOutlined, HomeOutlined, LogoutOutlined,} from '@ant-design/icons'
import './index.scss'

const {Header, Sider} = Layout

const items = [
    {
        label: '首页',
        key: '1',
        icon: <HomeOutlined/>,
    },
    {
        label: '文章管理',
        key: '2',
        icon: <DiffOutlined/>,
    },
    {
        label: '创建文章',
        key: '3',
        icon: <EditOutlined/>,
    },
]

const GeekLayout = () => {
    return (
        <Layout>
            <Header className="header">
                <div className="logo"/>
                <div className="user-info">
                    <span className="user-name">柴柴老师</span>
                    <span className="user-logout">
            <Popconfirm title="是否确认退出？" okText="退出" cancelText="取消">
              <LogoutOutlined/> 退出
            </Popconfirm>
          </span>
                </div>
            </Header>
            <Layout>
                <Sider width={200} className="site-layout-background">
                    <Menu
                        mode="inline"
                        theme="dark"
                        defaultSelectedKeys={['1']}
                        items={items}
                        style={{height: '100%', borderRight: 0}}></Menu>
                </Sider>
                <Layout className="layout-content" style={{padding: 20}}>
                    内容
                </Layout>
            </Layout>
        </Layout>
    )
}
export default GeekLayout

```

### 使用三方库初始化样式

src/main.tsx

```tsx
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './main.scss'
import {Provider} from "react-redux";
import store, {persistor} from "@/store";
import {PersistGate} from "redux-persist/integration/react";
import 'normalize.css'


ReactDOM.createRoot(document.getElementById('root')!).render(
    <Provider store={store}>
        {/*等待 Redux store 中的持久化数据加载完成后再渲染应用*/}
        <PersistGate loading={null} persistor={persistor}>
            <App/>
        </PersistGate>
    </Provider>
)

```

