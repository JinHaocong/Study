# vue3相比于vue2有哪些区别？

Vue.js 3相对于Vue.js 2有一些显著的区别和改进。以下是一些主要的区别：

1. **性能优化：** Vue 3在性能方面进行了许多优化。它引入了更快的虚拟DOM算法，称为Fragment API，以提高渲染性能。
2. **Composition API：** Vue 3引入了Composition API，这是一种新的组织组件逻辑的方式。它允许将组件的逻辑拆分为更小的功能性单元，使得代码更易读、可维护。
3. **Typescript支持：** Vue 3对TypeScript的支持更加友好。它是使用TypeScript编写的，因此在开发时可以获得更好的类型检查和自动补全。
4. **Teleport组件：** Vue 3引入了Teleport组件，允许您在DOM中的不同位置渲染组件的内容。这对于处理全局弹出框等情况非常有用。
5. **响应式系统改进：** Vue 3对响应式系统进行了改进，提供了更好的性能和更细粒度的控制。这包括reactive函数和ref函数等。
6. **更小的包大小：** Vue 3的包大小相对较小，这有助于减小应用程序的加载时间。
7. **全局API的变化：** 一些全局API的名称和用法在Vue 3中发生了变化，需要注意迁移指南中的更新。

这些只是一些主要的变化，还有其他一些较小的改进和新功能。在升级到Vue 3之前，建议查阅Vue.js官方文档中的迁移指南，以确保应用程序可以平稳过渡。

# OptionsAPI 与 CompositionAPI 有什么区别？

Vue.js 2.x 使用的是 Options API，而 Vue.js 3.x 引入了 Composition API。下面是两者之间的主要区别：

1. **组织代码的方式：**
   - **Options API：** 基于选项的 API，将组件的不同功能（data、methods、computed等）组织在不同的选项中。
   - **Composition API：** 基于函数的 API，通过函数的形式将组件的逻辑组织在一起。你可以使用 `setup` 函数来组织数据、计算属性、方法等。
2. **可复用性和逻辑组合：**
   - **Options API：** 在大型组件中，逻辑的复用和组合变得困难，因为不同功能的代码散布在不同的选项中。
   - **Composition API：** 提供了更好的可复用性和逻辑组合，通过将相关的逻辑放在一个函数中，可以更容易地组合和重用代码。
3. **逻辑封装：**
   - **Options API：** 逻辑通常分散在 `data`、`methods`、`computed` 等选项中，有时难以跟踪组件的整体逻辑。
   - **Composition API：** 通过 `setup` 函数，可以更清晰地封装组件的逻辑，使其更易于理解和维护。
4. **Typescript 支持：**
   - **Options API：** Typescript 支持较好，但在复杂组件中可能需要更多类型声明。
   - **Composition API：** 更灵活的类型推断和支持，特别适合在 Typescript 中编写组件。
5. **响应性：**
   - **Options API：** 使用 `data` 中的对象来实现响应性。
   - **Composition API：** 使用 `ref` 和 `reactive` 函数来实现响应性，提供了更直观的响应性 API。

总的来说，Composition API 提供了更灵活、可维护性更强、可复用性更好的方式来组织和管理组件的逻辑，特别是对于大型项目或需要更高抽象层次的场景。 Options API 仍然是Vue.js的一部分，并且在一些简单或小型项目中可能仍然是合适的选择。

# Vue3.0有什么更新

1. 性能优化：Vue.js 3.0使用了**Proxy**替代Object.defineProperty实现响应式，并且使用了静态提升技术来提高渲染性能。新增了编译时优化，在编译时进行模板静态分析，并生成更高效的渲染函数。
2. Composition API：Composition API是一个全新的组件逻辑复用方式，可以更好地组合和复用组件的逻辑。
3. TypeScript支持：Vue.js 3.0完全支持TypeScript，在编写Vue应用程序时可以更方便地利用TS的类型检查和自动补全功能。
4. 新的自定义渲染API：Vue.js 3.0的自定义渲染API允许开发者在细粒度上控制组件渲染行为，包括自定义渲染器、组件事件和生命周期等。
5. 改进的Vue CLI：Vue.js 3.0使用了改进的Vue CLI，可以更加灵活地配置项目，同时支持Vue.js2.x项目升级到Vue.js 3.0。
6. 移除一些API：Vue.js 3.0移除了一些不常用的API，如过渡相关API，部分修饰符等。

# Proxy和Object.defineProperty的区别？

Proxy和Object.defineProperty都可以用来实现JavaScript对象的响应式，但是它们有一些区别：

1. 实现方式：Proxy是ES6新增的一种特性，使用了一种代理机制来实现响应式。而Object.defineProperty是在ES5中引入的，使用了getter和setter方法来实现。
2. 作用对象：Proxy可以代理**整个对象**，包括对象的所有属性、数组的所有元素以及类似数组对象的所有元素。而Object.defineProperty**只能代理对象上定义的属性**。
3. 监听属性：Proxy可以监听到新增属性和删除属性的操作，而Object.defineProperty**只能监听到已经**定义的属性的变化。
4. 性能：由于Proxy是ES6新增特性，其内部实现采用了更加高效的算法，相对于Object.defineProperty来说在性能方面有一定的优势。

综上所述，虽然Object.defineProperty在Vue.js 2.x中用来实现响应式，但是在Vue.js 3.0中已经采用了Proxy来替代，这是因为Proxy相对于Object.defineProperty拥有更优异的性能和更强大的能力。

# Vue3升级了哪些重要功能？

- 新的API：Vue3使用createApp方法来创建应用程序实例，并有新的组件注册和调用方法。
- emits属性：：Vue 3的组件可以使用emits属性来声明事件。
- 生命周期
- 多个Fragment
- 移除.sync
- 异步组件的写法

```js
const Foo = defineAsyncComponent(() => import('./Foo.vue') )
```

# vue2和vue3 核心 diff 算法区别？

Vue 2.x使用的是双向指针遍历的算法，也就是通过逐层比对新旧虚拟DOM树节点的方式来计算出更新需要做的最小操作集合。但这种算法的缺点是，由于遍历是从左到右、从上到下进行的，当发生节点删除或移动时，会导致其它节点位置的计算出现错误，因此会造成大量无效的重新渲染。

Vue 3.x使用了经过优化的单向遍历算法，也就是只扫描新虚拟DOM树上的节点，判断是否需要更新，跳过不需要更新的节点，进一步减少了不必要的操作。此外，在虚拟DOM创建后，Vue 3会缓存虚拟DOM节点的描述信息，以便于复用，这也会带来性能上的优势。同时，Vue 3还引入了静态提升技术，在编译时将一些静态的节点及其子节点预先处理成HTML字符串，大大提升了渲染性能。

因此，总体来说，Vue 3相对于Vue 2拥有更高效、更智能的diff算法，能够更好地避免不必要的操作，并提高了渲染性能。

# Vue3为什么比Vue2快？

1. 响应式系统优化：Vue3引入了新的响应式系统，这个系统的设计让Vue3的渲染函数可以在编译时生成更少的代码，这也就意味着在运行时需要更少的代码来处理虚拟DOM。这个新系统的一个重要改进就是提供了一种基于Proxy实现的响应式机制，这种机制为开发人员提供更加高效的API，也减少了一些运行时代码。
2. 编译优化：Vue3的编译器对代码进行了优化，包括减少了部分注释、空白符和其他非必要字符的编译，同时也对编译后的代码进行了懒加载优化。
3. 更快的虚拟DOM：Vue3对虚拟DOM进行了优化，使用了跟React类似的Fiber算法，这样可以更加高效地更新DOM节点，提高性能。
4. Composition API：Vue3引入了Composition API，这种API通过提供逻辑组合和重用的方法来提升代码的可读性和重用性。这种API不仅可以让Vue3应用更好地组织和维护业务逻辑，还可以让开发人员更加轻松地实现优化。

# Vue3如何实现响应式？

使用Proxy和Reflect API实现vue3响应式。

Reflect API则可以更加方便地实现对对象的监听和更新，可以用来访问、检查和修改对象的属性和方法，比如`Reflect.get`、`Reflect.set`、`Reflect.has`等。

Vue3会将响应式对象转换为一个Proxy对象，并利用Proxy对象的get和set拦截器来实现对属性的监听和更新。当访问响应式对象的属性时，get拦截器会被触发，此时会收集当前的依赖关系，并返回属性的值；当修改响应式对象的属性时，set拦截器会被触发，此时会触发更新操作，并通知相关的依赖进行更新。

优点：可监听属性的变化、新增与删除，监听数组的变化

# vue3.0编译做了哪一些优化？

Vue 3.0作为Vue.js的一次重大升级，其编译器也进行了一些优化，主要包括以下几方面：

1. 静态树提升： Vue 3.0 通过重写编译器，实现对静态节点（即不改变的节点）进行编译优化，使用HoistStatic功能将静态节点移动到 render 函数外部进行缓存，从而服务端渲染和提高前端渲染的性能。
2. Patch Flag：在Vue 3.0中，编译的生成vnode会根据节点patch的标记，只对需要重新渲染的数据进行响应式更新，不需要更新的数据不会重新渲染，从而大大提高了渲染性能。
3. 静态属性提升：Vue3中对`不参与更新`的元素，会做静态提升，`只会被创建一次`，在渲染时直接复用。免去了重复的创建操作，优化内存。 没做静态提升之前，未参与更新的元素也在`render函数`内部，会重复`创建阶段`。
    做了静态提升后，未参与更新的元素，被`放置在render 函数外`，每次渲染的时候只要`取出`即可。同时该元素会被打上`静态标记值为-1`，特殊标志是`负整数`表示永远不会用于 `Diff`。
4. `事件监听缓存`：默认情况下绑定事件行为会被视为动态绑定（`没开启事件监听器缓存`），所以`每次`都会去追踪它的变化。`开启事件侦听器缓存`后，没有了静态标记。也就是说下次`diff算法`的时候`直接使用`。
5. 优化Render function：Vue 3.0的compile优化还包括：Render函数的换行和缩进、Render函数的条件折叠、Render函数的常量折叠等等。

总之，Vue 3.0通过多方面的编译优化，进一步提高了框架的性能和效率，使得Vue.js更加高效和易用。

# Vue3 的setup是什么？

在 Vue.js 3 中，`setup` 是 Composition API 的一部分，用于设置组件的逻辑和数据。`setup` 函数在组件创建阶段执行，它接收两个参数：`props` 和 `context`。

1. **`props` 参数：**
   - 用于接收组件的属性。在 `setup` 函数中，你可以直接访问传递给组件的 props。
2. **`context` 参数：**
   - 为了保持与 Options API 的一致性，`context` 参数提供了一个对象，包含了与组件实例相关的属性和方法，比如 `attrs`、`slots`、`emit` 等。

`setup` 函数返回一个对象，该对象中包含组件的响应式数据、计算属性、方法等。这个返回的对象将成为组件实例的上下文，你可以在模板中访问它的属性。

以下是一个简单的例子：

```vue
<script>
import { ref } from 'vue';

export default {
  props: {
    message: String
  },
  setup(props, context) {
    // 响应式数据
    const count = ref(0);

    // 计算属性
    const doubledCount = computed(() => count.value * 2);

    // 方法
    const increment = () => {
      count.value++;
      // 触发父组件的事件
      context.emit('increment');
    };

    return {
      count,
      doubledCount,
      increment
    };
  }
};
</script>
```

在这个例子中，`setup` 函数返回了一个包含响应式数据 `count`、计算属性 `doubledCount` 和方法 `increment` 的对象。这些数据和方法可以在组件的模板中直接使用，而不需要像 Options API 那样使用 `this`。

# setup与Options API的关系？

`setup` 函数是 Vue.js 3 中引入的 Composition API 的一部分，与 Options API 有一些重要的区别和关联。下面是它们之间的关系：

1. **Options API：**
   - Options API 是 Vue.js 2.x 中使用的默认 API。它将组件的不同功能（如数据、方法、生命周期钩子等）组织在不同的选项中，通过在组件对象中声明这些选项来定义组件。
2. **Composition API：**
   - Composition API 是 Vue.js 3 中引入的一种新的组织代码的方式。它允许你通过 `setup` 函数将组件的逻辑组织在一起，而不是散布在不同的选项中。这使得代码更加灵活、可维护性更强，并且更容易实现逻辑的复用和组合。
3. **关系：**
   - 在 Vue.js 3 中，你可以选择使用 Composition API 替代 Options API。`setup` 函数是 Composition API 的入口，它接受 `props` 和 `context` 作为参数，并返回一个对象，该对象包含组件的响应式数据、计算属性、方法等。这个返回的对象将成为组件实例的上下文。
4. **Options API 与 setup 的结合使用：**
   - 在 Vue.js 3 中，你可以选择将 Options API 与 Composition API 结合使用。你可以在组件中同时声明选项（如 `data`、`methods`）和使用 `setup` 函数。这种混合使用的方式在迁移逐步迁移到 Composition API 的过程中可能会有用。
5. **重名数据，方法以setup中为主**
6. **setup 比 data 执行的早**
7. **data 可以通过 this 读取 setup 中的数据，方法，反之不可以**

下面是一个简单的例子，展示了如何在 Vue.js 3 中同时使用 Options API 和 Composition API：

```vue
<template>
  <div class="person">
    <h2>姓名：{{name}}</h2>
    <h2>年龄：{{age}}</h2>
    <button @click="changeName">修改名字</button>
    <button @click="changeAge">修改年龄</button>
    <button @click="showTel">查看联系方式</button>
    <hr>
    <h2>测试1：{{a}}</h2>
    <h2>测试2：{{c}}</h2>
    <h2>测试3：{{d}}</h2>
    <button @click="b">测试</button>
  </div>
</template>

<script lang="ts">
  export default {
    name:'Person',
    beforeCreate(){
      console.log('beforeCreate')
    },
    data(){
      return {
        a:100,
        c:this.name,
        d:900,
        age:90
      }
    },
    methods:{
      b(){
        console.log('b')
      }
    },
    setup(){
      // 数据，原来是写在data中的，此时的name、age、tel都不是响应式的数据
      let name = '张三'
      let age = 18
      let tel = '13888888888'
      
      // 方法
      function changeName() {
        name = 'zhang-san' //注意：这样修改name，页面是没有变化的
        console.log(name) //name确实改了，但name不是响应式的
      }
      function changeAge() {
        age += 1 //注意：这样修改age，页面是没有变化的
        console.log(age) //age确实改了，但age不是响应式的
      }
      function showTel() {
        alert(tel)
      }

      // 将数据、方法交出去，模板中才可以使用
      return {name,age,tel,changeName,changeAge,showTel}

      // setup的返回值也可以是一个渲染函数
      // return ()=>'哈哈'
    }
  }
</script>

<style scoped>
  .person {
    background-color: skyblue;
    box-shadow: 0 0 10px;
    border-radius: 10px;
    padding: 20px;
  }
  button {
    margin: 0 5px;
  }
</style>
```

在这个例子中，`data` 选项用于声明响应式数据，而 `setup` 函数用于返回其他逻辑。这种方式允许逐步迁移到 Composition API。

# vue3 的 ref 和 reactive 有什么区别？

宏观角度看：

> 1. `ref`用来定义：**基本类型数据**、**对象类型数据**；
>
> 2. `reactive`用来定义：**对象类型数据**。

- 区别：

> 1. `ref`创建的变量必须使用`.value`（vscode 可以使用`volar`插件自动添加`.value`）。
>
>    <img src="E:/Study/study/6.Vue3/images/自动补充value.png" alt="自动补充value" style="zoom:50%;border-radius:20px" /> 
>
> 2. `reactive`重新分配一个新对象，会**失去**响应式（可以使用`Object.assign`去整体替换）。

- 使用原则：

> 1. 若需要一个基本类型的响应式数据，必须使用`ref`。
> 2. 若需要一个响应式对象，层级不深，`ref`、`reactive`都可以。
> 3. 若需要一个响应式对象，且层级较深，推荐使用`reactive`。

**ref表面上是创建了一个响应式对象，底层还是基于reactive的**

# toRef 和 toRefs 有什么区别？

`toRef` 和 `toRefs` 是 Vue 3 中提供的两个函数，用于在 Composition API 中处理响应式数据的函数。它们的主要区别在于处理对象时的方式。

1. **toRef:**

   - `toRef` 接受一个对象和对象的属性，返回一个 ref 对象，该 ref 对象绑定到原始对象的指定属性上。
   - 这意味着当你通过 `toRef` 创建的 ref 对象发生变化时，只会影响到原始对象中对应的属性，而不会影响整个对象。

   ```js
   import { ref, toRef } from 'vue';
   
   const originalObject = { key: 'value' };
   const myRef = toRef(originalObject, 'key');
   
   // 修改 myRef，不会影响整个 originalObject
   myRef.value = 'new value';
   ```

2. **toRefs:**

   - `toRefs` 接受一个响应式对象，返回一个包含该对象所有属性的 ref 对象的对象。
   - 这意味着你可以在解构时将整个对象的属性解构为独立的 ref 对象，然后分别访问和修改这些 ref 对象。

   ```js
   import { reactive, toRefs } from 'vue';
   
   const originalObject = reactive({ key1: 'value1', key2: 'value2' });
   const { key1Ref, key2Ref } = toRefs(originalObject);
   
   // 修改 key1Ref，只影响 originalObject 的 key1
   key1Ref.value = 'new value1';
   ```

总的来说，`toRef` 用于创建单个属性的 ref 对象，而 `toRefs` 用于将整个响应式对象的属性转换为 ref 对象，方便在组件中使用解构和分离处理属性。

# `watch`对比`watchEffect`有什么区别？

`watch` 和 `watchEffect` 是 Vue 3 提供的两种不同的响应式数据监听方法，它们之间有一些关键区别：

1. **用法：**
   - **`watch`：** 用于监视特定的响应式数据或计算属性，并在它们变化时执行回调函数。你需要明确指定要监视的数据，可以是一个 ref、reactive 对象的属性、computed 属性等。
   - **`watchEffect`：** 用于监听一个函数内部使用的响应式数据，当该函数内部的响应式数据发生变化时，自动执行该函数。不需要明确指定要监视的数据，函数内使用到的响应式数据会自动形成依赖关系。
2. **依赖追踪：**
   - **`watch`：** 需要显式指定要监视的响应式数据，只有指定的数据发生变化时才会执行回调函数。
   - **`watchEffect`：** 自动追踪函数内部使用到的响应式数据，所有被使用的响应式数据都会成为依赖。只要任何一个依赖变化，就会执行函数。
3. **返回值：**
   - **`watch`：** 返回一个停止监听的函数，可以用于停止 watch 的效果。
   - **`watchEffect`：** 不返回停止监听的函数，而是在组件卸载时自动停止监听。
4. **使用场景：**
   - **`watch`：** 适用于需要精确控制监视的数据和执行回调函数的场景，比如监视特定的数据变化后执行一些异步操作。
   - **`watchEffect`：** 适用于希望自动追踪函数内部响应式数据变化，并执行一些与 UI 无关的逻辑，比如数据收集、日志记录等。

`watch`与 `vue2.x`中 `watch` 配置功能一致，但也有两个小坑

- 监视 `reactive` 定义的响应式数据时，`oldValue` 无法正确获取，强`制开启`了深度监视（deep配置失效）
- 监视 `reactive` 定义的响应式数据中`某个属性`时，`deep配置有效`。

下面是一个简单的示例，演示了 `watch` 和 `watchEffect` 的使用：

```ts
<script lang="ts" name="Person" setup>
import { ref, watch, watchEffect } from 'vue'

// 数据
let temp = ref<number>(10)
let height = ref<number>(0)

// 方法
function changeTemp() {
  temp.value += 10
}

function changeHeight() {
  height.value += 10
}

// 监视 -- watch实现
watch([temp, height], ([newTemp, newHeight]: [number, number]) => {
  // 从value中获取最新的水温(newTemp)、最新的水位(newHeight)
  // 逻辑
  if (newTemp >= 60 || newHeight >= 80) {
    console.log('给服务器发请求')
  }
})

// 监视 -- watchEffect实现
watchEffect(() => {
  if (temp.value >= 60 || height.value >= 80) {
    console.log('给服务器发请求')
  }
})
</script>
```

`watch` 和 `watchEffect` 都能响应式地执行有副作用的回调。它们之间的主要区别是**追踪响应式依赖的方式**：

- `watch` 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。`watch` 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。
- `watchEffect`，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。

# 谈谈pinia?

[Pinia](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fpinia) 是 `Vue` 官方团队成员专门开发的一个全新状态管理库，并且 `Vue` 的官方状态管理库已经更改为了 `Pinia`。在 [Vuex](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvuex) 官方仓库中也介绍说可以把 `Pinia` 当成是不同名称的 `Vuex 5`，这也意味不会再出 `5` 版本了。

优点

- 更加轻量级，压缩后提交只有`1.6kb`。
- 完整的 `TS` 的支持，`Pinia` 源码完全由 `TS` 编码完成。
- 移除 `mutations`，只剩下 `state` 、 `actions` 、 `getters` 。
- 没有了像 `Vuex` 那样的模块镶嵌结构，它只有 `store` 概念，并支持多个 `store`，且都是互相独立隔离的。当然，你也可以手动从一个模块中导入另一个模块，来实现模块的镶嵌结构。
- 无需手动添加每个 `store`，它的模块默认情况下创建就自动注册。
- 支持服务端渲染（`SSR`）。
- 支持 `Vue DevTools`。
- 更友好的代码分割机制，[传送门](https://juejin.cn/post/7057439040911441957#heading-2)。

> `Pinia` 配套有个插件 [pinia-plugin-persist](https://link.juejin.cn/?target=https%3A%2F%2Fseb-l.github.io%2Fpinia-plugin-persist%2F)进行数据持久化，否则一刷新就会造成数据丢失

# EventBus与mitt区别？

`Vue2` 中我们使用 `EventBus` 来实现跨组件之间的一些通信，它依赖于 `Vue` 自带的 `$on/$emit/$off` 等方法，这种方式使用非常简单方便，但如果使用不当也会带来难以维护的毁灭灾难。

而 `Vue3` 中移除了这些相关方法，这意味着 `EventBus` 这种方式我们使用不了， `Vue3` 推荐尽可能使用 `props/emits`、`provide/inject`、`vuex` 等其他方式来替代。

当然，如果 `Vue3` 内部的方式无法满足你，官方建议使用一些外部的辅助库，例如：[mitt](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdevelopit%2Fmitt)。

优点

- 非常小，压缩后仅有 `200 bytes`。
- 完整 `TS` 支持，源码由 `TS` 编码。
- 跨框架，它并不是只能用在 `Vue` 中，`React`、`JQ` 等框架中也可以使用。
- 使用简单，仅有 `on`、`emit`、`off` 等少量实用API。

# script setup 是干啥的？

`scrtpt setup` 是 `vue3` 的语法糖，简化了`组合式 API` 的写法，并且运行性能更好。使用 `script setup` 语法糖的特点：

- 属性和方法无需返回，可以直接使用。
- 引入`组件`的时候，会`自动注册`，无需通过 `components` 手动注册。
- 使用 `defineProps` 接收父组件传递的值。
- `useAttrs` 获取属性，`useSlots` 获取插槽，`defineEmits` 获取自定义事件。
- 默认`不会对外暴露`任何属性，如果有需要可使用 `defineExpose` 。

# v-if 和 v-for 的优先级哪个高？

在 `vue2` 中 `v-for` 的优先级更高，但是在 `vue3` 中优先级改变了。`v-if` 的优先级更高。

# setup中如何获得组件实例？

在 `setup` 函数中，你可以使用 `getCurrentInstance()` 方法来获取组件实例。`getCurrentInstance()` 方法返回一个对象，该对象包含了组件实例以及其他相关信息。

以下是一个示例：

```javascript
import { getCurrentInstance } from 'vue';

export default {
  setup() {
    const instance = getCurrentInstance();

    // ...

    return {
      instance
    };
  }
};
```

在上面的示例中，我们使用 `getCurrentInstance()` 方法获取当前组件实例。然后，我们可以将该实例存储在一个常量中，并在 `setup` 函数的返回值中返回。

需要注意的是，`getCurrentInstance()` 方法只能在 `setup` 函数中使用，而不能在组件的生命周期方法（如 `created`、`mounted` 等方法）中使用。另外，需要注意的是，如果在 `setup` 函数返回之前访问了 `instance` 对象，那么它可能是 `undefined` ，因此我们需要对其进行处理。

# withDefaults 和 defineProps 都有什么作用？区别是什么？

`withDefaults` 和 `defineProps` 是 Vue 3 Composition API 中用于处理组件属性的两个不同函数。

### `defineProps`:

- **作用：** 用于在组件中定义接收的属性。

- **用法：** 在组件的 `setup` 函数中使用 `defineProps` 来声明组件接收的属性。这样做有助于类型检查，并且使属性在组件中的使用更加明确。

- 示例：

  ```ts
  import { defineProps } from 'vue';
  
  export default {
    props: ['name'],
    setup(props) {
      // 使用 defineProps 声明属性
      const { name } = defineProps(['name']);
  
      // 使用属性
      console.log(name);
  
      return {};
    },
  };
  ```

### `withDefaults`:

- **作用：** 用于在 `defineProps` 的基础上，提供默认值。

- **用法：** `withDefaults` 接受两个参数，第一个是 `defineProps` 的返回值，第二个是包含默认值的对象。它返回一个包含属性及其默认值的对象，这样你可以确保属性总是有一个值，即使它没有在父组件中传递。

- 示例：

  ```ts
  import { defineProps, withDefaults } from 'vue';
  
  export default {
    props: {
      name: String,
      age: {
        type: Number,
        default: 25,
      },
    },
    setup(props) {
      // 使用 defineProps 声明属性
      const { name, age } = defineProps(['name', 'age']);
  
      // 使用 withDefaults 提供默认值
      const propsWithDefaults = withDefaults(props, {
        age: 25,
      });
  
      // 使用属性及默认值
      console.log(name, age);
  
      return {};
    },
  };
  ```

### 区别：

- `defineProps` 主要用于声明接收的属性，并且可以进行类型检查。
- `withDefaults` 主要用于提供属性的默认值，它在 `defineProps` 的基础上添加了默认值的处理。

通常情况下，你会在 `setup` 函数中使用 `defineProps` 来声明接收的属性，并使用 `withDefaults` 来提供默认值。这两个函数结合使用可以方便地处理组件的属性。

# vue2 与 vue3 的生命周期分别是什么？

* 概念：`Vue`组件实例在创建时要经历一系列的初始化步骤，在此过程中`Vue`会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为：生命周期钩子

* 规律：

  > 生命周期整体分为四个阶段，分别是：**创建、挂载、更新、销毁**，每个阶段都有两个钩子，一前一后。

* `Vue2`的生命周期

  > 创建阶段：`beforeCreate`、`created`
  >
  > 挂载阶段：`beforeMount`、`mounted`
  >
  > 更新阶段：`beforeUpdate`、`updated`
  >
  > 销毁阶段：`beforeDestroy`、`destroyed`

* `Vue3`的生命周期

  > 创建阶段：`setup`
  >
  > 挂载阶段：`onBeforeMount`、`onMounted`
  >
  > 更新阶段：`onBeforeUpdate`、`onUpdated`
  >
  > 卸载阶段：`onBeforeUnmount`、`onUnmounted`

* 常用的钩子：`onMounted`(挂载完毕)、`onUpdated`(更新完毕)、`onBeforeUnmount`(卸载之前)

* 父子组件生命周期的关系：父-创建 => 父-挂载前 => 子-创建 => 子-挂载前 => 子-挂载完毕 => 父-挂载完毕

# vue3的自定义hook是什么？

在Vue.js 3中，自定义 Hook 是一种组织和重用逻辑的方式。自定义 Hook 实际上就是一个函数，以 "`use`" 开头命名，用于封装一些可复用的逻辑代码，可以在组件中使用。这样可以更好地组织代码，提高代码的可维护性和可复用性。

自定义 Hook 可以包含任何 Vue.js 特性，例如响应式数据、生命周期钩子等。通过使用自定义 Hook，可以将一些通用的逻辑抽离出来，使得多个组件可以共享同一段逻辑代码，避免代码重复。

例如，一个简单的自定义 Hook 可能如下所示：

```js
import { ref, onMounted } from 'vue';

function useCounter(initialValue) {
  const count = ref(initialValue);

  const increment = () => {
    count.value++;
  };

  const reset = () => {
    count.value = initialValue;
  };

  // 在组件被挂载时执行的生命周期钩子
  onMounted(() => {
    console.log('Counter component has been mounted');
  });

  // 返回需要在组件中使用的数据和方法
  return {
    count,
    increment,
    reset
  };
}

export default useCounter;
```

然后，你可以在组件中使用这个自定义 Hook：

```vue
<script>
import { defineComponent } from 'vue';
import useCounter from './useCounter';

export default defineComponent({
  setup() {
    const { count, increment, reset } = useCounter(0);

    return {
      count,
      increment,
      reset
    };
  }
});
</script>
```

这样，`useCounter` 就提供了一个可重用的计数器逻辑，可以在多个组件中使用。

# 路由器工作模式？

1. `history`模式

   > 优点：`URL`更加美观，不带有`#`，更接近传统的网站`URL`。
   >
   > 缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会有`404`错误。
   >
   > ```js
   > const router = createRouter({
   > 	history:createWebHistory(), //history模式
   > 	/******/
   > })
   > ```

2. `hash`模式

   > 优点：兼容性更好，因为不需要服务器端处理路径。
   >
   > 缺点：`URL`带有`#`不太美观，且在`SEO`优化方面相对较差。
   >
   > ```js
   > const router = createRouter({
   > 	history:createWebHashHistory(), //hash模式
   > 	/******/
   > })
   > ```

# vue3数据响应式是社么原理？与vue2有什么区别？


Vue 3 的数据响应式系统与 Vue 2 有一些重要的区别。Vue 3 的数据响应式系统基于 Proxy 对象，而 Vue 2 使用的是 Object.defineProperty。以下是一些主要的区别：

1. **Proxy vs. Object.defineProperty:**
   - Vue 3 使用 Proxy 对象来实现数据的响应式，这使得它能够捕捉更多的操作，包括数组的变化。
   - Vue 2 使用 Object.defineProperty 来劫持对象属性的 getter 和 setter，但它无法监听数组的变化，需要通过特殊的数组方法来实现。
2. **性能优化:**
   - 由于 Proxy 的设计，Vue 3 在性能上有一些优势。Proxy 可以直接监听整个对象的变化，而不需要遍历对象的每个属性。
   - Vue 2 的 Object.defineProperty 需要为每个属性单独设置 getter 和 setter，可能会导致性能瓶颈，特别是在处理大型对象时。
3. **Ref 和 Reactive:**
   - 在 Vue 3 中引入了 `ref` 和 `reactive` 函数，用于创建响应式对象。`ref` 主要用于包装基本类型，而 `reactive` 用于包装普通对象。
   - 在 Vue 2 中，使用 `new Vue()` 创建的实例对象本身就是响应式的。
4. **Composition API:**
   - Vue 3 引入了 Composition API，提供了更灵活和组织性更好的代码组织方式。这不仅仅是响应式系统的改变，而是一个更全面的 API 改进。
   - Vue 2 使用的是 Options API，相比之下，Composition API 允许更好地组织代码逻辑，特别是在处理复杂组件时。

总体而言，Vue 3 的数据响应式系统通过引入 Proxy 对象以及其他改进，提供了更好的性能和更灵活的开发体验。

# vue3 中的attrs是什么作用？

在Vue 3中，`attrs` 是一个用于接收父组件传递的非prop特性的对象。当一个子组件接收到来自父组件的属性，但这些属性在子组件中没有声明为props时，这些属性会被放入`attrs`对象中。

例如，考虑以下的父组件和子组件：

```vue
<!-- 父组件 ParentCom.vue -->
<template>
  <ChildCom
    msg="雷猴"
    data="123"
  />
</template>

<script setup>
import ChildCom from './ChildCom.vue'
</script>



<!-- 子组件 ChildCom.vue -->
<template>
  <div>
    {{ msg }} - {{ $attrs }}
  </div>
</template>

<script setup>
defineProps({
  msg: {
    type: String
  }
})
</script>
```

在上面的例子中，`title` 是通过props传递给子组件的，而 `customAttribute` 则不是通过props传递的，它会被放入`attrs`对象中。在子组件中通过`v-for`循环遍历`attrs`对象，你可以获取到所有父组件传递的非prop特性。

需要注意的是，如果你不设置 `inheritAttrs: false`，Vue 默认会将所有没有在子组件中声明的属性放入`attrs`中，但一旦你设置了 `inheritAttrs: false`，Vue 就只会将没有对应prop的属性放入`attrs`中。

# vue3中 默认插槽，具名插槽，作用域插槽是什么？有什么区别？

在Vue 3中，插槽是一种机制，允许你在父组件中将内容传递到子组件中，以便子组件可以渲染这些内容。Vue 3中有三种类型的插槽：默认插槽、具名插槽和作用域插槽。

1. **默认插槽（Default Slots）**:

   - 默认插槽是最基本的插槽类型，用于传递未命名的内容。
   - 在子组件中，你可以使用 `<slot>` 元素来表示默认插槽的位置。
   - 父组件中传递给子组件的内容会被放置在 `<slot>` 所在的位置。

   ```vue
   <!-- ParentComponent.vue -->
   <template>
     <ChildComponent>这是默认插槽的内容</ChildComponent>
   </template>
   ```

   ```vue
   <!-- ChildComponent.vue -->
   <template>
     <div>
       <p>子组件内容</p>
       <slot></slot> <!-- 这里是默认插槽的位置 -->
     </div>
   </template>
   ```

2. **具名插槽（Named Slots）**:

   - 具名插槽允许你在父组件中传递内容到特定的插槽位置。
   - 在子组件中，你可以使用 `<slot>` 元素的 `name` 属性来表示具名插槽的位置。
   - 父组件中通过使用 `<template>` 的 `v-slot` 指令来指定插槽的名称。

   ```vue
   <!-- ParentComponent.vue -->
   <template>
     <ChildComponent>
       <template v-slot:header>这是头部插槽的内容</template>
       <template v-slot:footer>这是底部插槽的内容</template>
     </ChildComponent>
   </template>
   ```

   ```vue
   <!-- ChildComponent.vue -->
   <template>
     <div>
       <p>子组件内容</p>
       <slot name="header"></slot> <!-- 头部插槽位置 -->
       <slot name="footer"></slot> <!-- 底部插槽位置 -->
     </div>
   </template>
   ```

3. **作用域插槽（Scoped Slots）**:

   - 作用域插槽允许子组件在插槽中使用父组件的数据。
   - 在子组件中，你可以使用 `<slot>` 元素的 `v-slot` 指令，并通过参数将数据传递给插槽。
   - 父组件中通过使用 `<template>` 的 `v-slot` 指令来指定插槽，并获取子组件传递的数据。

   ```vue
   <!-- ParentComponent.vue -->
   <template>
     <ChildComponent>
       <template v-slot:default="slotProps">
         {{ slotProps.message }}
       </template>
     </ChildComponent>
   </template>
   ```

   ```vue
   <!-- ChildComponent.vue -->
   <template>
     <div>
       <p>子组件内容</p>
       <slot :message="data.message"></slot> <!-- 作用域插槽位置 -->
     </div>
   </template>
   
   <script>
   export default {
     data() {
       return {
         message: '这是来自子组件的消息',
       };
     },
   };
   </script>
   ```

总体而言，这三种插槽类型提供了不同的灵活性，使得在父子组件之间传递内容更加方便。默认插槽用于传递未命名的内容，具名插槽用于传递到特定插槽位置的内容，而作用域插槽则允许子组件在插槽中使用父组件的数据。

# vue3中的customRef是什么？

在Vue 3中，`customRef` 是一个用于创建自定义的 ref 的函数。`ref` 是 Vue 3 中用于在响应式数据中包装普通 JavaScript 对象的工具函数，使其能够被 Vue 的响应式系统追踪变化。

`customRef` 允许你创建一个具有自定义 getter 和 setter 的 ref。这对于一些高级用例或需要定制 getter 和 setter 行为的情况很有用。

以下是 `customRef` 的基本用法：

```ts
import { customRef } from 'vue';

const myCustomRef = customRef((track, trigger) => {
  return {
    get() {
      // 在依赖项被追踪时调用
      track();
      // 返回值
      return someValue;
    },
    set(value) {
      // 在 ref 被修改时调用
      // 执行一些逻辑
      // ...
      // 触发更新
      trigger();
    }
  };
});

// 使用
const myRef = myCustomRef();
```

`customRef` 接受一个工厂函数，该函数接收两个参数：`track` 和 `trigger`。`track` 用于通知 Vue 追踪依赖，`trigger` 用于触发更新。在工厂函数中，你需要返回一个包含 `get` 和 `set` 方法的对象，这些方法定义了 ref 的 getter 和 setter。

这使你能够完全控制 ref 的行为，例如在设置值时执行特定的逻辑，或在获取值时进行

# Teleport 是什么？

将其插槽内容渲染到 DOM 中的另一个位置。

Vue 3 中新增了`teleport`（瞬移）组件，可以将组件的 DOM 插到指定的组件层，而不是默认的父组件层，可以用于在应用中创建模态框、悬浮提示框、通知框等组件。

- **Props**

  ```ts
  interface TeleportProps {
    /**
     * 必填项。指定目标容器。
     * 可以是选择器或实际元素。
     */
    to: string | HTMLElement
    /**
     * 当值为 `true` 时，内容将保留在其原始位置
     * 而不是移动到目标容器中。
     * 可以动态更改。
     */
    disabled?: boolean
  }
  ```

- **示例**

  指定目标容器：

  ```vue
  <Teleport to="#some-id" />
  <Teleport to=".some-class" />
  <Teleport to="[data-teleport]" />
  ```

  有条件地禁用：

  ```vue
  <Teleport to="#popup" :disabled="displayVideoInline">
    <video src="./my-movie.mp4">
  </Teleport>
  ```